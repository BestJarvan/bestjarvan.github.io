[{"title":"puppeteer生成pdf卡顿解决方案","url":"/2023/12/28/node/puppeteer-pdf/","content":"\n> 最近公司线上pdf生成缓慢，经常超过30s导致请求超时断开，通过排查问题，找到下面这条issues，可解决目前问题\n\nchromium升级到119之后导致原本20页的pdf生成超级慢，通过打印时间发现`puppeteer`的`page.pdf()`方法转换html到pdf用时达到20s左右，根据issues修改版本号降级到Chromium(117.0.5938.92)对照puppeteer的21.3.2版本\n\n\n\n降级后`page.pdf`方法生成20页pdf从原本20s降低到680ms，提升将近30倍，整体接口返回时间大概5s左右\n\n\n\n- Issues: [#11494](https://github.com/puppeteer/puppeteer/issues/11494)\n\n- `puppeteer`和`chromium`对照表: [support](https://pptr.dev/chromium-support)\n\n- 依赖对照表(提示缺少依赖可以对比安装): [Chrome doesn't launch on Linux](https://pptr.dev/troubleshooting#chrome-doesnt-launch-on-linux)\n\n- 中文乱码: 需要自行下载字体库\n``` shell\n# 在字体文件目录安装字体\nsudo mkfontscale\nsudo mkfontdir\nsudo fc-cache -fv\n```\n\n\n![#11494](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/image-20231228174532723.png)\n\n","tags":["nodejs","puppeteer"],"categories":["node"]},{"title":"Serve-Send Events(SSE) + Visibility API项目中应用","url":"/2023/12/10/js/sse/","content":"\n>最近收到一个需求，需要做一套消息中心，需求倒是很简单，再用户有新消息时推送给web页面，提示用户有新消息未读，最初版本用短轮询方案实现，若是局部组件，可关闭页面后结束轮询，但是此消息中心是一个全局组件，只要开启页面就开始轮询，体验不佳，看着network密密麻麻的请求头都大了，随使用SSE方案。\n\n### 对于这种消息推送目前几个成熟方案：\n\n1. 客户端轮询 (短轮询)\n2. 服务端轮询 (长轮询)\n3. WebSocket\n4. SSE (Serve-Send Events)\n\n<!-- more -->\n\n![短轮询](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/WX20231205-151930.png)\n\n### 各方案间区别：\n\n|*|客户端轮询|服务端轮询|WebSocket|SSE|\n|--|--|--|--|--|\n|协议|http|http|tcp|http|\n|优点|实现方便，兼容性好|同短轮询，但比短轮询节约资源，相对短轮询请求次数少|双全工通信协议，性能开销相对较小，可双向通信|H5规范的一部分，无需安装直接使用；资源占用小；前端部分实现极其简单|\n|缺点|占用较多内存和请求数；污染network列表|同短轮询|开发成本高；相对sse资源开销大|单向推送；兼容性问题；只能get请求，且请求头无法加内容(或者使用第三方封装sse插件)|\n\n### SSE兼容问题：\n\n![兼容浏览器](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/image-20231210170510078.png)\n\n### SSE实现\n\n#### 1. 前端实现 + visibilitychange性能优化\n\n经过测试环境几天的运行发现了新的问题，当用户挂机时，js代码也在正常的跑，如果用户忘记关闭页面，且电脑从不关机，就会导致页面请求每隔一小时发送一次，实际绝大部分挂机时间不需要维持此链接，那么我们可以通过`visibilitychange`事件优化我们的消息通知\n\n![visible](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/image-20231212104513647.png)\n\n通过mdn文档可知，我们可以通过`visible`和`hidden`去优化我们的代码\n\n以下代码为最新代码，带浏览器降级处理\n\n```javascript\n// 如果断开链接15秒后重试，网络故障、接口故障等重连需要\nconst RETRY_TIME = 15 * 1000\n// 生命周期中初始化\nmounted() {\n  // 初始化插件\n  this.initNotify()\n  // 挂载监听器\n  this.initListener()\n},\n\nmethods: {\n  // 生命周期中初始化此插件\n  initNotify() {\n    if ('EventSource' in window) {\n      // 第一次刷新消息数\n      this.getUnReadNoticeCount()\n      // 注册sse\n      this.registerEvent()\n    } else {\n      // 不兼容走短轮询\n      clearTimeout(this.timer)\n      this.loopFetch()\n    }\n  },\n  // 注册监听器\n  initListener() {\n    document.addEventListener('visibilitychange', this.listeningChange)\n  },\n  // 监听回调事件\n  listeningChange() {\n    if (document.visibilityState === 'hidden') {\n      // 不可见清空所有定时器\n      this.clearAllTimer()\n    } else if (this.eventSource) {\n      if (this.eventSource.readyState === 2) {\n        // 变为可见时，且sse已断开，则重新连接\n        this.registerEvent()\n      }\n    } else {\n      // 降级处理\n      this.loopFetch()\n    }\n  },\n  // 注册事件\n  registerEvent() {\n    if (document.visibilityState === 'visible') {\n      const now = new Date().getTime()\n      if (!this.sourceTime || (now - this.sourceTime) >= RETRY_TIME) {\n        this.sourceTime = new Date().getTime()\n        const user = getUserInfo()\n        const userId = user ? JSON.parse(user).userId : ''\n        // notifyNumUrl = 'https://xxxx/message-center/sse/create?userId='+id;\n        this.eventSource = new EventSource(notifyNumUrl(userId))\n        console.log('eventSource: ', this.eventSource);\n        // 链接成功回调\n        this.eventSource.onopen = () => {\n          clearTimeout(this.errorTimer)\n        }\n        // 持续接受消息\n        this.eventSource.onmessage = ({ data }) => {\n          if (data) {\n            this.noticeNum = data\n          }\n        }\n        // 失败回调\n        this.eventSource.onerror = (error) => {\n          if (error.currentTarget.readyState === 2) {\n            this.eventSource.close && this.eventSource.close()\n            this.registerEvent()\n          }\n        }\n      } else {\n        this.errorTimer = setTimeout(() => {\n          this.registerEvent()\n        }, RETRY_TIME)\n      }\n    }\n  },\n  // 降级处理，递归轮询接口\n  loopFetch() {\n    this.getUnReadNoticeCount()\n    this.timer = setTimeout(() => {\n      this.loopFetch()\n    }, 1000 * 30)\n  },\n  // 请求处理\n  getUnReadNoticeCount() {\n    // api请求\n  },\n  // 页面销毁时清除定时器\n \tclearAllTimer() {\n    if (this.eventSource) {\n      clearTimeout(this.errorTimer)\n    } else {\n      clearTimeout(this.timer)\n    }\n  },\n},\n\n// 页面销毁时清除定时器\nbeforeDestroy() {\n  document.removeEventListener('visibilitychange', this.listeningChange)\n  this.clearAllTimer()\n  this.eventSource && this.eventSource.close && this.eventSource.close()\n},\n```\n\n\n\n#### 2. 后端实现 JAVA Spring Web MVC\n\n```java\n@RestController\n@RequestMapping(\"/sse\")\n@Api(tags = \"Sse消息通知\")\n@Slf4j\npublic class SseController extends BaseController {\n    @Resource\n    private SseService sseService;\n\n    /**\n     * 创建新连接\n     * @return\n     */\n    @GetMapping(\"/create\")\n    public Object createSession(String userId) throws IOException {\n        return sseService.createSession(userId);\n    }\n\n    /**\n     * 关闭连接\n     * @return\n     */\n    @GetMapping(\"/close\")\n    public void closeSession(String userId) throws IOException {\n        sseService.closeSession(userId);\n    }\n}\n\n@DubboService\n@Service\n@Slf4j\npublic class SseServiceImpl implements SseService {\n\n    public final static Map<String, SseEmitter> SSE_CACHE= new ConcurrentHashMap<>();\n\n    public final static Map<String, Integer> SEND_RECORD= new ConcurrentHashMap<>();\n\n    /**\n     *  创建连接\n     * @return\n     */\n    public synchronized SseEmitter createSession(String clientId) throws IOException{\n        //需要手动清理（非正常关闭的情况下会一直保留原先的通道造成消息发送失败）\n        SEND_RECORD.remove(clientId);\n        // 过期时间设置为0，表示永不过期\n        SseEmitter sseEmitter = new SseEmitter(0L);\n        SSE_CACHE.put(clientId,sseEmitter);\n        log.info(\"客户端：{}  新建连接成功，当前客户端总数为【{}】\",clientId,SSE_CACHE.size() );\n        return sseEmitter;\n    }\n\n    @Override\n    public void closeSession(String clientId) {\n        if (SSE_CACHE.containsKey(clientId)){\n            SSE_CACHE.get(clientId).complete();\n            SSE_CACHE.remove(clientId);\n            SEND_RECORD.remove(clientId);\n            log.info(\"客户端：【{}】 断开成功，当前剩余客户端总数为【{}】\",clientId,SSE_CACHE.size());\n        }\n    }\n}\n\n\n\n\n@XxlJob(\"sendUnRead\")\npublic void sendUnRead(){\n    if (SseServiceImpl.SSE_CACHE.size()>0){\n        List<UnReadNoticePO> unReadNoticePOS = noticeService.countAllUnReadNotice(new ArrayList<>(SseServiceImpl.SSE_CACHE.keySet()));\n        log.info(\"stringIntegerMap\",unReadNoticePOS);\n        if(CollectionUtil.isNotEmpty(unReadNoticePOS)){\n\n            for (Map.Entry<String, SseEmitter> entry : SseServiceImpl.SSE_CACHE.entrySet()) {\n                String key = entry.getKey();\n                Optional<UnReadNoticePO> first = unReadNoticePOS.stream().filter(u -> u.getUserId().equals(key)).findFirst();\n\n                if(first.isPresent()){\n                    log.info(\"first\",first.get());\n                    SseEmitter sseEmitter = SseServiceImpl.SSE_CACHE.get(key);\n                    try {\n                        Integer lastNum = SseServiceImpl.SEND_RECORD.get(first.get().getUserId());\n                        if(ObjectUtil.isEmpty(lastNum) || lastNum!=first.get().getNum()){\n                            sseEmitter.send(SseEmitter.event().reconnectTime(1000).id(entry.getKey()).data(first.get().getNum()));\n                            log.info(entry.getKey()+\"发送消息成功，内容：{}\",first.get().getNum());\n                        }\n                        SseServiceImpl.SEND_RECORD.put(first.get().getUserId(),first.get().getNum());\n                    }catch (IOException e){\n                        //发送失败，移除\n                        SseServiceImpl.SSE_CACHE.remove(entry.getKey());\n                        log.error(entry.getKey()+\"消息发送失败，通道已关闭!\",e);\n\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n#### 3. 运维\n\n运维需要配合修改`nginx`配置的`proxy-read-timeout`超时时间，目前我们方案超时时间一小时。\n\n### 成品展示\n\n此时只保留一条http请求，后端轮询到新消息就推送到前端，若前端页面不显示或被隐藏(锁屏切标签等)则不去请求，若页面显示则自动恢复请求。方便快捷，体验更好\n\n![network](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/image-20231210173206861.png)\n\n\n\n","tags":["javascript","SSE"],"categories":["js"]},{"title":"Xbox One手柄改TypeC尾插","url":"/2023/09/20/notes/xbox-one/","content":"\n本次改装按照[Foundries](https://space.bilibili.com/57800164)大佬的教程搞得，附带一些个人心得\n\n### 准备的工具和材料\n* 贴片式Type C 16Pin 母口\n* 热风枪(没有可以用打磨笔+电烙铁慢慢搞)\n* 电烙铁，焊锡，助焊剂\n* 六角螺丝刀(T6用于拆主板螺丝，外壳螺丝需要专用的防盗螺丝刀拆)\n* 30AWG跳线\n* 打磨笔(有更好，没也行)\n* 镊子\n* 5.1k ohm电阻*2(触发PD快充需要，最好准备0805，0603各一颗)\n* 0.1mm漆包线\n* M1*2*1.5螺丝两颗(可选，主要是固定尾插用)\n* AB树脂结构胶(可选)\n* 光固化绿油和固化灯\n* 聚酰亚胺胶带\n* 万用表\n\n<!-- more -->\n\n\n准备好工具后开搞，最难的第一步，type c母座改造\n\n### 一、改造typec母座\n按照[Xbox手柄改Type C接口](https://www.bilibili.com/read/cv22153887/?spm_id_from=333.999.collection.opus.click)焊接，难点在于电阻的焊接，太小了，没放大镜很费眼\n\n![拔除A4B9，B8，A8引脚](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201150656.png)\n拔除A4B9，B8，A8引脚\n\n这几个引脚最好拔除，方便为后续焊接提供空间\n\n![0805和0603电阻，阻值5.1k](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201411213.jpeg)\n0805和0603电阻，阻值5.1k\n\n![拔除引脚后用聚酰亚胺胶带隔热](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201416284.jpeg)\n拔除引脚后用聚酰亚胺胶带隔热\n\n![IMG_6485](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201417443.jpeg)\n\n![IMG_6486](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201418882.JPG)\n\n改造后的16pin typec母座\n\n焊接完成后可以用『安全充电多功能检测仪』测一下充电电压有没有5v，没有检测仪的话可以用万用表测一下有没有引脚短接，啥都没就肉眼看下确保焊锡没有短接到其他引脚\n\n![222](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201418762.png)\n\n测试输入电压5v，成功触发快充\n\n\n\n没问题后焊接跳线，为后续焊接pcb做准备\n\n![IMG_6487](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201418730.jpeg)\n\n千万别连锡短接，做好绝缘\n### 二、PCB改造\n![WX20230920-141950@2x](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201420331.png)\n\n处理旧的尾插，此处一定要处理平整，这样才美观\n\n\n\n* 把旧的尾插拔除，这里我没有热风枪，选择了蛮力，直接把焊盘拔掉了，不过当时脑子抽，没有打磨平整，就开始后续操作了，导致这里不平整，typec尾插翘起来一小块(不影响使用，就是不美观了)\n* M1的螺丝拧入原尾插的插槽内，这里M1的螺丝不要选择铝制，不吃锡，最好拧进去前找一颗实验下吃不吃锡，不吃的话尽早处理下这两个螺丝，比如洁厕灵涂一下侵蚀表面，不然拧上去发现不吃锡就很尴尬了\n\n### 三、飞线焊接\n![WX20230920-142057@2x](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201421380.png)\n\n> D-和D+线焊接在1号位时，能获得最好的ESD保护，但比较难焊接。2号位是一个很大的测试点，方便焊接（图中被我测试时，搞掉了）。3号点是最后的选择。\n> \n> 将A7,B7飞线到D-位，A6，B6飞线到D+位。\n> \n> 最佳的飞线方式是B7焊接一根短线到A7，B6焊接一根短线到A6。A6, A7再飞线到PCB。这需要熟练的焊接能力。\n> \n> 差一点的方式是A6, A7飞线到PCB，然后B6, B7通过飞线中途接入A6，A7的飞线上。\n> \n> 最差的便是4根线直接飞线到PCB上。\n> \n> 布线过程中，尽量保证等长，贴近！！！\n\n这里我选择焊接到2号位，2号位置焊接空间相对大一些\n\n![IMG_6489 11.25.51](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201422315.jpeg)\n\n焊接后涂一层绿油固定\n这里绿油涂多了，后面用刷子刷薄，太厚不利于光照固化，可以看到焊2号位操作空间有多大，这么一大坨焊锡，手残的我也能焊上\n\n### 四、打磨外壳\n先上大佬的完美作品\n\n![33](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201424204.jpg)\n\n![44](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201422616.jpg)\n\n大佬作品\n\n![IMG_6506](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201423308.jpeg)\n\n我的丑照\n\n此处就是第二步pcb处理时候，旧的焊盘没有处理平整，导致typec尾插不平，后面翘起一点，没办法重新处理，只能强行剪开外壳，让c口没有能正常使用\n\n这里我固定尾插第一次用了焊锡，拔插几次后焊锡断开，后面用了AB树脂结构胶固定，固化时间大概5分钟初始固化到24小时固化完全，这次很稳，拔插稳定\n\n![IMG_6507](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309201423403.jpeg)\n\nQC2.0\n这里可以看到，装机完成后插入充电可以触发QC2.0快充协议\n\n至此，改造完成","tags":["xbox","DIY"],"categories":["notes"]},{"title":"解决puppeteer依赖chromium内核下载失败问题","url":"/2023/09/19/node/puppeteer/","content":"\n1. 本地可使用代理魔法上网安装\n\n2. 服务器安装\n配置puppeteer环境变量，使用国内镜像源下载\n\nps: v20.1.1(2023-05-05)版本更新 PUPPETEER_DOWNLOAD_HOST 环境变量改为 PUPPETEER_DOWNLOAD_BASE_URL\n\n```shell\n# v20.1.1之前版本\nnpm config set puppeteer_download_host=https://npmmirror.com/mirrors/\n# 备用镜像地址\nnpm config set puppeteer_download_host=\"https://cdn.npmmirror.com/binaries/\"\n\n# v20.1.1以及之后版本\nnpm config set puppeteer_download_base_url=https://npmmirror.com/mirrors/\n# 备用镜像地址\nnpm config set puppeteer_download_base_url=https://cdn.npmmirror.com/binaries/chrome-for-testing/\n\n# 不需要下载则需要补充环境变量，跳过下载内核步骤\nPUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true\n```\n","tags":["nodejs","puppeteer"],"categories":["node"]},{"title":"从零搭建前端脚手架CLI工具","url":"/2023/09/05/node/myself-cli/","content":"\n#### 目录结构\n\n首先从零搭建一套前端脚手架需要用到最核心的一个库就是[`commander`](https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md)\n\n![commanderjs](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309051127055.png)\n<!-- more -->\n\n[github仓库](https://github.com/BestJarvan/helper-cli)\n完整目录\n\n```javascript\n.\n├── bin // 脚本识别文件\n│   └── helper-cli // 脚本\n├── lib // 需要的方法等\n│   ├── deploy.js\n│   ├── init-token.js\n│   └── logo.js\n├── package.json\n└── session // 存放一些临时文件\n    └── token.json\n```\n\n\n\n#### 修改package文件\n\n `package.json`需要配置`bin`字段，指明脚本入口文件和脚本命令的名称\n\n```json\n{\n  // ...\n\t\"bin\": {\n\t\t\"helper-cli\": \"./bin/helper-cli\"\n\t}\n  // ...\n}\n```\n\n\n\n#### helper-cli的开发\n\n1. 首先需要声明运行环境 `#!/usr/bin/env node` 指明使用`node`运行此脚本\n2. 使用`program`注册命令名称和说明等\n3. 使用`action`调用命令的执行函数\n\n```javascript\n#!/usr/bin/env node\n\nconst { program } = require('commander')\nconst chalk = require('chalk')\nconst leven = require('leven')\nconst pkg = require('../package.json')\nconst logo = require('../lib/logo')\n\nprogram\n  .version(`${pkg.name}: ${pkg.version}`, '-v, --version')\n  .usage('<command> [options]')\n\nprogram\n  .command('jenkins')\n  .alias('jk')\n  .description('Init jenkins Token')\n  .action(() => {\n    logo()\n    require('../lib/init-token')()\n  })\n\nprogram\n  .command('deploy <name> [branch]')\n  .alias('dp')\n  .description('Deploy the project (<name>) to the test environment')\n  .action((name, branch) => {\n    logo()\n    require('../lib/deploy')(name, branch)\n  })\n\nprogram\n  .arguments('<command>')\n  .action((cmd) => {\n    program.outputHelp()\n    console.log(`  ` + chalk.red(`Unknown command ${chalk.yellow(cmd)}.`))\n    console.log()\n    suggestCommands(cmd)\n  })\n\nprogram.parse(process.argv)\n\nfunction suggestCommands (unknownCommand) {\n  const availableCommands = program.commands.map(cmd => cmd._name)\n\n  let suggestion\n\n  availableCommands.forEach(cmd => {\n    const isBestMatch = leven(cmd, unknownCommand) < leven(suggestion || '', unknownCommand)\n    if (leven(cmd, unknownCommand) < 3 && isBestMatch) {\n      suggestion = cmd\n    }\n  })\n\n  if (suggestion) {\n    console.log(`  ` + chalk.red(`Did you mean ${chalk.yellow(suggestion)}?`))\n  }\n}\n\n```\n\n#### lib文件的开发\n\n1. `init-token`文件，使用[`inquirer`](https://www.npmjs.com/package/inquirer)库完成命令行的指令交互\n\n```javascript\nconst chalk = require(\"chalk\")\nconst figlet = require(\"figlet\")\nconst path = require('path')\nconst fs = require('fs')\nconst { default: confirm } = require(\"@inquirer/confirm\")\nconst { default: input } = require('@inquirer/input')\n\n// 可以默认给初始值\nlet account = \"default\"\nlet token = \"defaultToken\"\n\nasync function initToken () {\n  const answer = await confirm({ message: '初始化本地jenkins配置, 是否使用默认配置 ?', default: false });\n  if (!answer) {\n    account = await input({ message: 'jenkins账号:' })\n    token = await input({ message: 'jenkins密码(token):' })\n  }\n  genTokenFile()\n}\n\nfunction genTokenFile () {\n  try {\n    fs.writeFileSync(path.join(__dirname, '../session', 'token.json'), `{ \"account\": \"${account}\", \"token\": \"${token}\" }`)\n    console.log('jenkins配置初始化完成')\n    console.log(\n      chalk.green(\n        figlet.textSync(\"SUCCESS\", {\n          font: \"Soft\",\n          horizontalLayout: \"default\",\n          verticalLayout: \"default\"\n        })\n      )\n    );\n  } catch (error) {\n    console.error('error: ', error);\n  }\n}\n\nmodule.exports = initToken\n```\n\n2. `deploy.js`和第一版相似，修改触发方法\n\n```javascript\nconst Jenkins = require('jenkins')\nconst fs = require('fs')\nconst path = require('path')\nconst { exec } = require('child_process')\nconst package = require('../package.json')\n\nconst auth = {}\nlet jobName = ''\n\nlet jenkins\nlet branchName = 'test'\n\n// 接受两个参数，branch为可选参数，默认test\nfunction deploy (name, branch) {\n  jobName = name\n  if (branch) {\n    branchName = branch\n    initJenkins()\n  } else {\n    getGitBranch()\n      .then(res => {\n        branchName = res\n        initJenkins()\n      })\n  }\n}\n\nasync function initJenkins() {\n  try {\n    const data = fs.readFileSync(path.join(__dirname, '../session', 'token.json'), 'utf8')\n    Object.assign(auth, JSON.parse(data))\n    try {\n      jenkins = new Jenkins({\n        baseUrl: `https://${auth.account}:${auth.token}@jenkins-test.xxx.com`,\n      })\n      triggerBuild()\n    } catch (error) {\n      console.log(error);\n      process.exit(0)\n    }\n  } catch (error) {\n    console.error(`配置文件未找到，请先运行 ${package.name} jk 生成配置文件`)\n    process.exit(0)\n  }\n}\n\n\nfunction getGitBranch() {\n  return new Promise((resolve, reject) => {\n    exec('git rev-parse --abbrev-ref HEAD', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`)\n        reject()\n        return;\n      }\n      resolve(stdout.trim())\n    })\n  })\n}\n\nasync function triggerBuild() {\n  try {\n    const result = await jenkins.job.build({\n      name: jobName,\n      parameters: {\n        branch: branchName,\n        merge: true\n      },\n      token: auth.token\n    })\n    console.log('准备构建...', result)\n    waitOnQueue(result)\n  } catch (error) {\n    console.error('error: ', error);\n  }\n}\n\nasync function waitOnQueue(id) {\n  const result = await jenkins.queue.item(id)\n  if (result.executable) {\n  console.log('开始构建: ', jobName);\n    setTimeout(() => {\n      logBuild(result.executable.number)\n    }, 500);\n  } else if (result.cancelled) {\n    console.log('构建已取消')\n  } else {\n    setTimeout(() => {\n      waitOnQueue(id)\n    }, 500);\n  }\n}\n\nfunction logBuild(id) {\n  console.log('构建中...', id)\n  const log = jenkins.build.logStream(jobName, id);\n\n  log.on(\"data\", (text) => {\n    process.stdout.write(text);\n  });\n\n  log.on(\"error\", (err) => {\n    console.log(\"error\", err);\n  });\n\n  log.on(\"end\", () => {\n    console.log(\"success: 构建完成.\");\n  });\n}\n\nmodule.exports = deploy\n```\n\n#### `logo.js`全局的logo输出\n\n```javascript\nconst chalk = require('chalk')\nconst figlet = require(\"figlet\")\n\nmodule.exports = () => {\n  console.log(\n    chalk.cyan(\n      figlet.textSync(\"Helper CLI\", {\n        font: \"Ghost\",\n        horizontalLayout: \"default\",\n        verticalLayout: \"default\",\n        width: 100\n      })\n    )\n  );\n}\n```\n\n![logo](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309051142236.png)\n\n\n开发中我们可以使用`npm link` 把我们开发中的指令关联到全局指令中，我们可以全局使用`helper-cli -h`查看帮助\n\n![help](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202309051144103.png)\n\n\n\n开发调试完成后，我们可以发布到npm市场，或者公司内部私有npm平台，提供给项目使用，如果非全局安装，可以配合项目内的`.npmrc`指定本CLI的安装源\n\n","tags":["javascript","nodejs","CLI"],"categories":["node"]},{"title":"通过node调用Jenkins API完成构建过程","url":"/2023/08/28/node/node-jenkins/","content":"\n#### 前言\n项目中使用jenkins挺久了，每次发布测试环境代码都需要手动去jenkins上发布，特别麻烦，想到两种解决方案，一种是通过CI/CD持续集成，一种是通过jenkins API调用配制好的job。\n\n* 第一种方案需要触发，还要推送代码到指定分支，不能完美解决目前的痛点。\n* 第二种方案灵活配置，手动触发，在需要的时候构建，可以解决目前的痛点。\n\n本文就讲解如何通过API完成测试环境的构建工作，生产环境不推荐这样做，生产环境一般都有严格的上线流程和权限控制。\n\n![image-20230831200429836](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202308312004869.png)\n\n<!-- more -->\n[github仓库](https://github.com/BestJarvan/helper-cli)\n\n#### 构建脚本\n1. 首先我们在项目中新建(若没有)`build`文件夹，新建`jenkins.js`存放我们的脚本\n2. 安装[Jenkins](https://github.com/silas/node-jenkins) -> `npm install --save-dev jenkins`\n3. 示例代码如下\n4. 把脚本添加到`package.json`的`script`中，新增`\"deploy:jen\": \"node ./build/jenkins\"`\n5. 我们运行`npm run deploy:jen`\n\n```javascript\nconst Jenkins = require('jenkins')\n\n// 分支名\nconst branchName = 'test'\n// 项目名\nconst jobName = 'example'\n// 授权信息\nconst auth = {\n  username: 'username',\n  // 推荐使用jenkins token，在个人设置中生成\n  password: 'password'\n}\nconst jenkins = new Jenkins({\n  // https://用户名:密码/token@jenkins地址\n  baseUrl: `https://${auth.username}:${auth.password}@jenkins.xxx.com`,\n})\n\nasync function triggerBuild() {\n  try {\n    const result = await jenkins.job.build({\n      name: jobName,\n      // jenkins中需要的参数，若无则为空\n      parameters: {\n        branch: branchName,\n        merge: true\n      },\n      token: auth.password\n    })\n    console.log('开始构建...', result)\n  } catch (error) {\n    console.error('error: ', error);\n  }\n}\n\ntriggerBuild()\n```\n\n此时我们已经可以触发构建流程，但是不够完美，发布分支需要我们写死，且我们并不知道构建进度，所以我们需要借助`child_process`查看分支和`jenkins.build.logStream`实时查看构建进度\n\n#### 动态配置分支名&输出进度\n在第一步的基础上，我们进行完善\n```javascript\nconst Jenkins = require('jenkins')\nconst { exec } = require('child_process');\n\n// 分支名初始化\nconst branchName = 'test'\n// jenkins的job名\nconst jobName = 'example'\n// 授权信息\nconst auth = {\n  username: 'username',\n  password: 'password'\n}\nconst jenkins = new Jenkins({\n  // https://用户名:密码/token@jenkins地址\n  baseUrl: `https://${auth.username}:${auth.password}@jenkins.xxx.com`,\n})\n\ngetGitBranch()\n  .then(res => {\n    branchName = res\n    triggerBuild()\n  })\n\n// 获取当前分支\nfunction getGitBranch() {\n  return new Promise((resolve, reject) => {\n    exec('git rev-parse --abbrev-ref HEAD', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`)\n        reject()\n        return;\n      }\n      resolve(stdout.trim())\n    })\n  })\n}\n\n// 触发构建\nasync function triggerBuild() {\n  try {\n    const result = await jenkins.job.build({\n      name: jobName,\n      // jenkins中需要的参数，若无则为空\n      parameters: {\n        branch: branchName,\n        merge: true\n      },\n      token: auth.token\n    })\n    console.log('准备构建...', result)\n    waitOnQueue(result)\n  } catch (error) {\n    console.error('error: ', error);\n  }\n}\n\n// 轮训查看当前构建状态\nasync function waitOnQueue(id) {\n  const result = await jenkins.queue.item(id)\n  if (result.executable) {\n  console.log('开始构建: ', jobName);\n    setTimeout(() => {\n      logBuild(result.executable.number)\n    }, 500);\n  } else if (result.cancelled) {\n    console.log('构建已取消')\n  } else {\n    setTimeout(() => {\n      waitOnQueue(id)\n    }, 500);\n  }\n}\n\n// 输出编译结果\nfunction logBuild(id) {\n  console.log('构建中...', id)\n  const log = jenkins.build.logStream(jobName, id);\n\n  log.on(\"data\", (text) => {\n    process.stdout.write(text);\n  });\n\n  log.on(\"error\", (err) => {\n    console.log(\"error\", err);\n  });\n\n  log.on(\"end\", () => {\n    console.log(\"success: 构建完成.\");\n  });\n}\n\n```\n\n此时，我们已经完善了我们的发布脚本，但是项目中会有多个开发需要使用此脚本，认证信息如果可以动态配置，那就更好了。我们可以通过`node`脚本或者`shell`完成这一想法。\n\n#### 编写shell脚本完成用户账号信息配置\n1. `build`文件中新增`jenkins-init.sh`文件，参考第四步\n\n2. 文件内脚本需要完成三个个操作\n    1. 允许用户输入账号信息\n    2. 内置默认账号配置\n    3. 存入账号信息到json中\n    \n3. 在`package.json`的`script`中新增`\"init:jen\": \"sh ./build/jenkins-init.sh\"`\n\n4. 修改`jenkins.js`脚本，读取配置账号信息\n\n5. `shell`脚本会自动在`build`文件夹下生成一个`token.json`的文件，可以把这个文件加入到`.gitignore`里面，不需要提交到远端\n\n    ![image-20230831200256923](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202308312002955.png)\n\n#### 完整版\njenkins-init\n```shell\n#!/usr/bin/env sh\n\nset -e\nACCOUNT=\"\"\nTOKEN=\"\"\nread -p \"初始化本地jenkins配置, 是否使用默认配置 ? (y/n)\" -n 1 -r\n\nif [[ $REPLY =~ ^[Yy]$ ]]\n  then\n    echo \"\"\n    ACCOUNT=\"username\"\n    TOKEN=\"password|token\"\n  else\n    echo \"\"\n    echo \"jenkins账号:\"\n    # 20s超时自动断\n    read -t 20 ACCOUNT\n\n    echo \"jenkins密码(token):\"\n    read -t 20 TOKEN\nfi\n# 存入配置文件\necho '{\"account\": \"'$ACCOUNT'\", \"token\": \"'$TOKEN'\"}' > ./build/token.json\necho \"jenkins配置初始化完成\"\n```\njenkins.js\n```javascript\nconst Jenkins = require('jenkins')\nconst fs = require('fs')\nconst path = require('path')\nconst { exec } = require('child_process');\n\nconst auth = {}\nconst jobName = 'example'\n\nlet jenkins\nlet branchName = 'test'\n\ngetGitBranch()\n  .then(res => {\n    branchName = res\n    initJenkins()\n  })\n\nfunction initJenkins() {\n  try {\n    const data = fs.readFileSync(path.join(__dirname, './', 'token.json'), 'utf8')\n    Object.assign(auth, JSON.parse(data))\n    jenkins = new Jenkins({\n      baseUrl: `https://${auth.account}:${auth.token}@jenkins.xxx.com`,\n    })\n    triggerBuild()\n  } catch (error) {\n    console.error('配置文件未找到，请先运行npm run init:jen 生成配置文件')\n  }\n}\n\n\nfunction getGitBranch() {\n  return new Promise((resolve, reject) => {\n    exec('git rev-parse --abbrev-ref HEAD', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`)\n        reject()\n        return;\n      }\n      resolve(stdout.trim())\n    })\n  })\n}\n\nasync function triggerBuild() {\n  try {\n    const result = await jenkins.job.build({\n      name: jobName,\n      // jenkins中需要的参数，若无则为空\n      parameters: {\n        branch: branchName,\n        merge: true\n      },\n      token: auth.token\n    })\n    console.log('准备构建...', result)\n    waitOnQueue(result)\n  } catch (error) {\n    console.error('error: ', error);\n  }\n}\n\nasync function waitOnQueue(id) {\n  const result = await jenkins.queue.item(id)\n  if (result.executable) {\n  console.log('开始构建: ', jobName);\n    setTimeout(() => {\n      logBuild(result.executable.number)\n    }, 500);\n  } else if (result.cancelled) {\n    console.log('构建已取消')\n  } else {\n    setTimeout(() => {\n      waitOnQueue(id)\n    }, 500);\n  }\n}\n\nfunction logBuild(id) {\n  console.log('构建中...', id)\n  const log = jenkins.build.logStream(jobName, id);\n\n  log.on(\"data\", (text) => {\n    process.stdout.write(text);\n  });\n\n  log.on(\"error\", (err) => {\n    console.log(\"error\", err);\n  });\n\n  log.on(\"end\", () => {\n    console.log(\"success: 构建完成.\");\n  });\n}\n```\n\n![image-20230831200141757](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202308312001802.png)\n\n开发拉取代码后，首次需要运行`npm run init:jen`生成配置文件，之后每次发布测试环境可以运行`npm run deploy:jen`触发构建，若需要合并test分支，则可以在jenkins中配置自动合并。\n\n至此，我们实现了可自由配置账号信息，手动触发jenkins构建，并且查看构建进度的脚本。\n\n\n\n#### 第二版，通过CLI发布\n\n此版本更适合多项目发布，提取到npm可全局安装或项目安装，比第一版本更加灵活。\n\n[从零搭建前端脚手架CLI工具](https://www.jiangyh.cn/2023/09/05/node/myself-cli/index.html)","tags":["javascript","nodejs","jenkins","shell"],"categories":["node"]},{"title":"iTerm2快捷键大全","url":"/2023/05/16/node/iterm2/","content":"\n#### **标签操作**\n\n新建标签：`command + t`\n\n关闭标签：`command + w`\n\n切换标签：`command + 数字 / command + 左右方向键`\n\n切换全屏：`command + enter`\n\n查找：`command + f`\n\n#### **分屏操作**\n\n垂直分屏：`command + d`\n\n水平分屏：`command + shift + d`\n\n切换屏幕：`command + option + 方向键 / command + [ / command + ]`\n\n查看历史命令：`command + ;`\n\n查看剪贴板历史：`command + shift + h`\n\n#### **其他**\n\n选中即复制，在iterm2中选中内容就已经复制到了剪切板\n\n清除当前行：`ctrl + u`\n\n到行首：`ctrl + a`\n\n到行尾：`ctrl + e`\n\n前进后退：`ctrl + f/b (相当于左右方向键)`\n\n上一条命令：`ctrl + p`\n\n搜索命令历史：`ctrl + r`\n\n删除当前光标的字符：`ctrl + d`\n\n删除光标之前的字符：`ctrl + h`\n\n删除光标之前的单词：`ctrl + w`\n\n删除到文本末尾：`ctrl + k`\n\n交换光标处文本：`ctrl + t`\n\n清屏1：`command + r`\n\n清屏2：`ctrl + l`\n\n\n\n原文地址: [知乎](https://zhuanlan.zhihu.com/p/114232649)\n","tags":["iTerm2"],"categories":["notes"]},{"title":"微前端方案对比","url":"/2022/12/25/vue/micro-frontends/","content":"## 什么是微前端\n\n微前端类似微服务，并不是指某一具体的技术，而是一种整合了技术、策略和方法的**宏观架构方案**，是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。\n\n## 为什么选择微前端\n\n微前端主要解决了两个问题:\n\n1. 项目迭代导致巨石应用，难以维护\n\n2. 兼容历史应用，实现增量开发\n\n<!-- more -->\n\n优点:\n\n1. 更灵活的技术栈选择\n2. 拓展多个技术团队\n\n3. 更快且独立的部署\n4. ...\n\n缺点:\n\n1. 用户层面，不连贯的体验问题\n2. 多项目、多语言造成的维护成本增加\n\n## [Why Not Iframe](https://www.yuque.com/kuitos/gky7yw/gesexv)\n\n## 微前端框架选择\n\n本次改造使用一下技术栈\n\n基座应用vue2.x\n\n子应用vue2.x\n\n路由模式均为`hash`\n\n### 一. [qiankun](https://github.com/umijs/qiankun)\n\n![d1a6cb48359cf96be6b4cd750a241dfa.png](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202303201601278.png)\n\n图片来源：https://blog.csdn.net/xgangzai/article/details/128489706\n\n#### 基座应用\n\n1. 手动加载(可手动，可自动，自动加载需要修改main.js入口文件)\n\n```html\n<!-- qiankun路由落地页面 -->\n<template>\n  <div :id=\"instantId\"></div>\n</template>\n\n<script>\nimport { registerMicroApps, loadMicroApp, start } from 'qiankun';\n\nexport default {\n  name: 'index',\n\n  props: {\n    // 实例id\n    instantId: {\n      type: String,\n      default: 'sub-app-viewport'\n    },\n    // 入口\n    entry: {\n      type: String,\n      default: '//localhost:7101',\n    }\n  },\n\n  mounted () {\n    this.$nextTick(async () => {\n      this.$once('unmount', () => {\n        console.log('%cqiankun unmount！！！', 'color: orange;font-size: 32px')\n        this.app.unmount('#/qiankun')\n        this.app = null\n      })\n\n\n      const getActiveRule = (hash) => (location) => location.hash.startsWith(hash);\n\n      this.app = loadMicroApp({\n        name: 'vueApp', // app name registered\n        entry: this.entry,\n        container: `#${this.instantId}`,\n        activeRule: getActiveRule('#/qiankun'),\n      }, {\n        singular: true\n      })\n\n      console.log('%cqiankun app =====', 'color: orange;font-size: 32px', this.app)\n    })\n  },\n\n  destroyed () {\n    if (!this.app) return\n    this.app.unmount()\n    this.app = null\n  },\n}\n</script>\n```\n\n2. 路由改造\n\n```javascript\n// router.js\nimport Qiankun from '@/views/qiankun/index'\n\nconst routes = [\n  {\n    path: '/',\n    component: Layout,\n    redirect: '/dashboard',\n    children: [\n      {\n        path: 'dashboard',\n        name: 'Dashboard',\n        component: () => import('@/views/dashboard/index'),\n        meta: { title: '首页', icon: 'dashboard', affix: true }\n      },\n      // 匹配所有/qiankun路径，防止找不到报错404\n      {\n        path: 'qiankun/*', // 在主应用中，所有的/qiankun/*路径指向子应用\n        component: Qiankun,\n        hidden: true\n      },\n    ]\n  },\n]\n\n```\n\n\n\n#### 子应用\n\n1. 改造入口文件，暴露生命周期\n\n```javascript\n// main.js\nimport Vue from 'vue';\nimport './public-path'\n\nlet instance = null;\n\nfunction render(props = {}) {\n  const { container } = props;\n\n  instance = new Vue({\n    router,\n    store,\n    render: h => h(App),\n  }).$mount(container ? container.querySelector('#app') : '#app');\n}\n\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped');\n}\n\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props);\n  render(props);\n}\n\nexport async function unmount() {\n  instance.$destroy();\n  instance.$el.innerHTML = '';\n  instance = null;\n  // router = null;\n}\n\n```\n\n2. 新增`public-path.js`文件，并在`main.js`引入\n\n```javascript\nif (window.__POWERED_BY_QIANKUN__) {\n  // eslint-disable-next-line no-undef\n  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n}\n\n```\n\n3. 改造路由\n\n```javascript\n// router.js\nimport Layout form '@/components/layout'\nimport { name } from \"../../package.json\"\n\nconst flag = !!window.__POWERED_BY_QIANKUN__\n// 动态前缀，可以写死，这里用的项目名作为前缀，如果独立运行则为/\nconst prefixPath = flag ? `/${name}` : '/'\n\nconst routes = [\n  {\n    path: prefixPath,\n    component: Layout,\n    children: [\n      // 其他的路由都写到这里\n      {\n        path: 'home',\n        name: 'home',\n        meta: {\n          // requireAuth: true\n        },\n        component: () => import('@/views/home')\n      },\n    ],\n  },\n];\n```\n\n4. 改造`webpack`打包\n\n```javascript\n// vue.config.js\nconst { name } = require('./package.json')\n\nmodule.exports = {\n  devServer: {\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\": \"*\",\n      \"Access-Control-Allow-Methods\": \"*\",\n    },\n    port: 7101\n  },\n  chainWebpack: config => {\n    config.output\n      .library(`${name}-[name]`)\n      .libraryTarget('umd')\n      .jsonpFunction(`webpackJsonp_${name}`)\n      .filename('js/[name].[hash].js')\n      .chunkFilename('js/[name].[hash].js')\n      .end();\n  }\n}\n\n```\n\n\n\n优点:\n\n  1. 社区活跃，框架经过多个项目打磨，更加成熟\n  2. 社区demo多，案例多\n  3. 完备的沙箱方案，js 沙箱做了 `SnapshotSandbox`、`LegacySandbox`、`ProxySandbox` 三套渐进增强方案，css 沙箱做了 `strictStyleIsolation`、`experimentalStyleIsolation` 两套适用不同场景的方案\n\n缺点:\n\n  1. 项目侵入性强，接入成本高\n  2. 页面展示多个子应用时，需要使用 `momery` 路由\n  3. 官方文档比较简洁，需要多去社区看demo\n\n\n\n### 二. [wujie](https://github.com/Tencent/wujie)\n\n![img](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202303201438420.webp)\n\n#### 基座应用\n\n1. 改造入口文件，注入无界\n\n```javascript\n// main.js\nimport WujieVue from 'wujie-vue2'\n\nconst { setupApp, preloadApp, bus } = WujieVue;\n\nVue.use(WujieVue)\n\npreloadApp({\n  name: 'vue2'\n})\n\n\n```\n\n2. 新建无界页面，路由跳这里\n\n```html\n<template>\n  <WujieVue\n    width=\"100%\"\n    height=\"100%\"\n    v-bind=\"options\"\n  ></WujieVue>\n</template>\n\n<script>\n// 推荐抽离到公共js中或单独一个js\nconst lifecycles = {\n  beforeLoad: (appWindow) => console.log(`${appWindow.__WUJIE.id} beforeLoad 生命周期`),\n  beforeMount: (appWindow) => console.log(`${appWindow.__WUJIE.id} beforeMount 生命周期`),\n  afterMount: (appWindow) => console.log(`${appWindow.__WUJIE.id} afterMount 生命周期`),\n  beforeUnmount: (appWindow) => console.log(`${appWindow.__WUJIE.id} beforeUnmount 生命周期`),\n  afterUnmount: (appWindow) => console.log(`${appWindow.__WUJIE.id} afterUnmount 生命周期`),\n  activated: (appWindow) => console.log(`${appWindow.__WUJIE.id} activated 生命周期`),\n  deactivated: (appWindow) => console.log(`${appWindow.__WUJIE.id} deactivated 生命周期`),\n  loadError: (url, e) => console.log(`${url} 加载失败`, e),\n};\n\nexport default {\n  name: 'wujie',\n\n  data () {\n    return {\n      options: {\n        name: 'vue2',\n        url: '//localhost:9001/#/',\n        exec: true,\n        sync: true, // 路由同步\n        props: {\n          params: 1,\n          methods: () => {\n            console.log(123)\n          }\n        }, // 传参给子路由\n        ...lifecycles // 生命周期\n      }\n    }\n  },\n  \n  mounted () {\n    // 根据基座应用路由分析跳转到子应用对应页面\n    const routerStr = location.hash.replace('#/wujie/', '')\n    this.options.url += routerStr\n  },\n}\n</script>\n\n```\n\n#### 子应用\n\n1. 改造入口文件\n\n```javascript\n// main.js\n\n// 子路由接收方式\nwindow.$wujie?.props // { params: 1, methods: function }\nwindow.$wujie?.props.methods()\n\n// 生命周期改造\nif (window.__POWERED_BY_WUJIE__) {\n  let instance;\n  window.__WUJIE_MOUNT = () => {\n    instance = new Vue({\n      router,\n      store,\n      render: (h) => h(App)\n    }).$mount(\"#app\");\n  };\n  window.__WUJIE_UNMOUNT = () => {\n    instance.$destroy();\n  };\n} else {\n  new Vue({\n    router,\n    store,\n    render: h => h(App)\n  }).$mount('#app');\n}\n\n```\n\n\n\n优点:\n\n  1. 改造成本低，有基于vue的`wujie-vue`和react的` wujie-react`封装，开箱即用\n  2. 子应用加载和普通 vue 组件加载并无二致，所有配置都收敛到组件的属性上。\n  3. `webcomponent` + `shadowdom`、js-iframe原生沙箱\n  4. 支持`plugin`\n  5. 子应用保活\n  6. 更方便的全局组件挂载\n  7. 浏览器降级处理\n\n缺点:\n\n  1. 社区不如qiankun和micro-app活跃\n\n\n\n### 三、[micro-app](https://github.com/micro-zoe/micro-app)\n\n![image](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202303171505687.png)\n\n#### 基座应用\n\n1. 基座应用改造侵入性小\n\n```javascript\n// 安装\n// npm i @micro-zoe/micro-app --save\n\n// main.js\nimport Vue from 'vue'\nimport microApp from '@micro-zoe/micro-app'\n\nmicroApp.start()\n\n// 预加载\nmicroApp.preFetch([\n  { name: 'myApp', url: '//localhost:9001' }\n])\n\n// 子应用卸载\nwindow.addEventListener('unmount', function () {\n  // 执行卸载相关操作\n})\n\n...\nVue.config.productionTip = false\n\nnew Vue({\n  el: '#app',\n  render: (h) => h(App),\n})\n\n```\n\n2. 分配路由\n\n```javascript\n// router.js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport MyPage from './my-page.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    // 👇 非严格匹配，/my-page/* 都指向 MyPage 页面\n    path: '/micro/*', // vue-router@4.x path的写法为：'/my-page/:page*'\n    name: 'micro',\n    component: MyPage,\n  },\n]\n\nexport default routes\n```\n\n3. 页面中使用，数据通信，生命周期\n\n```html\n<!-- my-page.vue -->\n<template>\n  <micro-app\n    name='myApp'\n    url='//localhost:9001'\n    baseroute='/micro'\n    :data='dataForChild'\n    @created='handleLifecycle'\n    @beforemount='handleLifecycle'\n    @mounted='handleLifecycle'\n    @unmount='handleLifecycle'\n    @error='handleLifecycle'\n    @datachange='handleDataChange'\n  ></micro-app>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      dataForChild: {type: '发送给子应用的数据'}\n    }\n  },\n  methods: {\n    handleLifecycle (e) {\n      console.log('触发生命周期：', e.type)\n    },\n    handleDataChange (e) {\n      console.log('来自子应用的数据：', e.detail.data)\n    }\n  }\n}\n</script>\n\n...\n```\n\n\n\n#### 子应用\n\n1. 子应用改造\n\n```javascript\n// main.js\nimport Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\n\n// 返回基座下发的data数据\nconst data = window.microApp.getData()\nconsole.log(data)\n\n// 发送数据给基座应用，dispatch只接受对象作为参数\nwindow.microApp.dispatch({type: '子应用发送的数据'})\n\n// umd模式，性能优化，适合频繁挂载、卸载子应用\nlet app = null\n// 👇 将渲染操作放入 mount 函数 -- 必填\nfunction mount () {\n  app = new Vue({\n    router,\n    store,\n    render: h => h(App)\n  }).$mount('#app');\n}\n\n// 👇 将卸载操作放入 unmount 函数 -- 必填\nfunction unmount () {\n  app.$destroy()\n  app.$el.innerHTML = ''\n  app = null\n}\n\n// 微前端环境下，注册mount和unmount方法\nif (window.__MICRO_APP_ENVIRONMENT__) {\n  window[`micro-app-${window.__MICRO_APP_NAME__}`] = { mount, unmount }\n} else {\n  // 非微前端环境直接渲染\n  mount()\n}\n```\n\n2. 路由改造\n\n```javascript\n// router.js\nimport VueRouter from 'vue-router';\nimport layOut from '@/components/layOut'\n\nconst routes = [\n  {\n    path: window.__MICRO_APP_BASE_ROUTE__ || '/',\n    component: layOut,\n    children: [\n      ...\n    ]\n  }\n]\n\nconst router = new VueRouter({\n  mode: \"hash\",\n  // base: process.env.BASE_URL,\n  base: window.__MICRO_APP_BASE_ROUTE__ || '/',\n  routes\n});\n\nexport default router;\n\n```\n\n路由约束：\n\n- 基座是hash路由，子应用也必须是hash路由\n- 基座是history路由，子应用可以是hash或history路由\n\n基础路由：\n\n1. 如果基座是history路由，子应用是hash路由，不需要设置基础路由baseroute\n\n2. 如果子应用只有一个页面，没有使用`react-router`，`vue-router`之类，也不需要设置基础路由baseroute\n\n3. `vue-router`在hash模式下无法通过base设置基础路由，需要创建一个空的路由页面，将其它路由作为它的children\n\n`Proxy`代理保证`window`的纯净，因`Proxy`没有更好的`polyfill`方案，所以不支持`Proxy`的浏览器(IE、低版本iOS等)无法运行micro-app\n\n\n\n优点：\n\n1. 改造成本对比qiankun有所降低\n2. 简单的子应用(无路由跳转等)开箱即用\n3. 支持`plugin`\n4. `webcomponet`、js沙箱、`ShadowDom`等\n5. 子应用保活\n6. 文档详细、完善，官方手把手demo教学，社区相对活跃\n\n缺点:\n\n1. 复杂子应用有改造成本，需要改造路由才可以正常使用\n2. 公用组件挂载麻烦，没有原生支持\n3. 低版本浏览器兼容问题(IE等不支持`Proxy`的浏览器)\n\n\n\n### 四. [garfish](https://github.com/web-infra-dev/garfish)\n\n![设计理念](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202303161957251.image)\n\n### 五. 本地跨域解决方案\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  devServer: {\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\": \"*\",\n      \"Access-Control-Allow-Methods\": \"*\",\n    },\n  },\n}\n\n```\n","tags":["vue","微前端","qiankun","wujie","micro-app"],"categories":["vue"]},{"title":"手写call、apply、bind与this指向问题","url":"/2022/08/15/js/手写call、apply、bind与this指向问题/","content":"\n> 本文给大家介绍更完善的手写方法\n>\n> 虽然手写call，apply，bind网上已经大把大把的文章，且本身知识点比较集中，但是网上的大部分方法都会有这样或者那样的问题，并不完善\n>\n> 本文带大家从另一个角度，更加完善的理解、学习如何手写call、apply、bind\n\n### 一、用法与区别\n\n1. call：\n\n   `call()` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。\n\n2. apply：\n\n   `apply()` 方法调用一个指定 `this` 值的函数，以及以一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的形式提供的参数。\n\n3. bind：\n\n   `bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n<!-- more -->\n> 总结：call和apply传参不同，但都会调用函数。bind传参和call一样，但是bind会返回this改变后的函数，并不会立即调用。\n\n```javascript\nvar name = 'lisi'\n\nconst obj = {\n\tname: 'zhangsan'\n}\n\nfunction getName (age, hobby) {\n  console.log(`我叫${this.name}，今年${age}岁，喜欢${hobby}`,)\n}\n\ngetName(20，'电脑') // '我叫lisi，今年20岁，喜欢电脑'\ngetName.call(obj, 18, '跳舞') // '我叫zhangsan，今年18岁，喜欢跳舞'\ngetName.apply(obj, [18, '跳舞']) // '我叫zhangsan，今年18岁，喜欢跳舞'\ngetName.bind(obj, 18, '跳舞')() // '我叫zhangsan，今年18岁，喜欢跳舞'\n\n```\n\n\n\n### 二、什么是this\n\n`this` 是指当前函数中正在执行的**上下文环境**，也就是说，`this`指向谁是调用时确定的，而非文本定义。\n\n其次关于`this`，需要记住一句话 ———— 谁调用就指向谁\n\n\n\n### 三、如何判断this指向\n\n关于`this`指向问题，非严格模式下一般有以下几种情况：\n\n1. 全局环境下的this指向: window\n\n   ```javascript\n   console.log(this) // window\n   ```\n\n2. 函数内的this: \n\n      ```javascript\n   var name = 'lisi'\n   function getName () {\n     console.log(this.name)\n   }\n      \n   getName() // lisi\n   // 等同于\n   window.getName() // lisi\n      ```\n\n3. 对象中的this: \n\n   ```javascript\n   const obj = {\n   \tname: 'zhangsan',\n     getName: function () {\n       console.log(this.name)\n     }\n   }\n   obj.getName() // zhangsan\n   ```\n\n4. 箭头函数中的this: 箭头函数中没有 this， 它会绑定最近的非箭头函数作用域中的this。首先从它的父级作用域找，如果父级作用域还是箭头函数，就再往上找，一层一层的直到找到this的指向\n\n5. 构造函数中的this: 指向实例，因为通过new关键字构建后已经改变this指向\n\n6. 原型链中的this: 1, 看是谁调用 2, 进行this替换 3, 基于原型链确认结果\n\n   ```javascript\n   function Person (name, age) {\n     this.name = name\n     this.age = age\n   }\n   \n   Person.prototype.getAge = function () {\n     console.log(this.age)\n   }\n   \n   Person.prototype.addHobby = function () {\n   \tthis.hobby = '干饭'\n   }\n   \n   const personA = new Person('zhangsan', 18)\n   personA.name // zhangsan  this=>personA\n   personA.getAge() // 18 this=>personA\n   personA.__proto__.name // undefined this=>Person.prototype\n   Person.prototype.age // undefined this=>Person.prototype\n   personA.addHobby() // personA实例上添加hobby字段 this=>personA\n   Person.prototype.addHobby() // Person实例上添加hobby字段 this=>Person\n   \n   ```\n\n\n\n### 四、手写call、apply、bind\n\n根据上述的第三条this指向，我们可以通过构造一个对象来使得改变this的指向，那么我们手写call就有了下面的思路\n\n```javascript\nFunction.prototype.myCall = function (ctx, ...args) {\n  ctx.fn = this\n  ctx.fn(...args)\n  delete ctx.fn\n}\n\n// test\nconst obj = {\n  name: 'zhangsan'\n}\nfunction test () {\n  console.log(this.name)\n}\ntest() // undefined\ntest.myCall(obj) // zhangsan\n```\n\n我们可以发现，上述方法可以实现改变this的指向，但是上述方法又会存在一些弊端\n\n1. 如果对象里面有`fn`方法，会替换掉对象中的`fn`方法，哪怕改成很偏僻的`__fn`等等，都会存在风险，其次也不美观\n2. 如果传入的`ctx`是普通数据类型或者空值，比如`number`，`string`，`null`,`undefined`等\n3. 如果函数有返回值，那么这种方法就没办法接收到返回值\n\n那么我们该如何去优化上面的myCall呢？\n\n思考一下\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n接下来针对上述几个问题进行改进\n\n1. `fn`命名冲突问题，我们可以借助es6的`Symbol`解决\n\n   ```javascript\n   // 因为Symbol的唯一性，导致\n   const a = Symbol('a')\n   const b = Symbol('a')\n   a == b // false\n   // 所以我们使用完必须删除Symbol，保证对象的干净\n   ```\n\n2. 普通数据类型和空值，我们可以通过三目去解决\n\n3. 返回值，我们可以单独接收，最后`return`出去\n\n> 此处使用`globalThis`原因是js运行环境有两种，一种是浏览器中，一种是Node环境，所以使用js内置全局属性来判断\n\n```javascript\nFunction.prototype.myCall = function (ctx, ...args) {\n  ctx = ctx === null || ctx === undefined ? globalThis : Object(ctx)\n  const key = Symbol('fn')\n  ctx[key] = this\n  const res = ctx[key](...args)\n  delete ctx[key]\n  return res\n}\n\n// test\nconst obj = {\n  name: 'zhangsan'\n}\ntest.myCall(null) // this\ntest.myCall(2) // undefined\ntest.myCall(obj) // zhangsan\n```\n\n测试没问题后，我们可以参考myCall手写剩下的两个myApply和myBind\n\n```javascript\nFunction.prototype.myApply = function (ctx, args) {\n  ctx = ctx === null || ctx === undefined ? globalThis : Object(ctx)\n  // 防止args没有或传值不对\n  args = Array.isArray(args) ? args : []\n  const key = Symbol('fn')\n  ctx[key] = this\n  const res = ctx[key](...args)\n  delete ctx[key]\n  return res\n}\n\nFunction.prototype.myBind = function (ctx, ...args1) {\n  ctx = ctx === null || ctx === undefined ? globalThis : Object(ctx)\n  const key = Symbol('fn')\n  ctx[key] = this\n  \n  return function (...args2) {\n    const res = ctx[key](...args1, ...args2)\n    delete ctx[key]\n    return res\n  }\n}\n```\n\n下面我们请出特约嘉宾`zhangsan`和`lisi`，帮我们跑一下测试用例，验证下方法的可靠性\n\n```javascript\nvar name = 'lisi'\nconst obj = {\n  name: 'zhangsan'\n}\n\nfunction test (...args) {\n  console.log(`我是: ${this.name}, 我收到了一些参数: ${args}`)\n}\n\nfunction testReturnValue (...args) {\n  console.log(`我是: ${this.name}, 我收到了一些参数: ${args}`)\n  return '没错就是我'\n}\n\n// 思考下下面会输出什么结果\ntest.myCall(obj)\ntest.myCall(obj, 1, 2, 3)\nconst a = testReturnValue.myCall(obj)\nconst a2 = testReturnValue.myCall(obj, 1, 2, 3)\n\ntest.myApply(obj)\ntest.myApply(obj, 1)\ntest.myApply(obj, [1])\n\ntest.myBind(obj)()\ntest.myBind(obj, 1, 2)()\ntest.myBind(obj, 1, 2)(3, 4)\n\n\n\n\n\n// 输出，从上到下，按顺序排列\n// 我是: zhangsan, 我收到了一些参数:\n// 我是: zhangsan, 我收到了一些参数: 1,2,3\n// 我是: zhangsan, 我收到了一些参数:  a => 没错就是我\n// 我是: zhangsan, 我收到了一些参数: 1,2,3  a => 没错就是我\n\n// 我是: zhangsan, 我收到了一些参数:\n// 我是: zhangsan, 我收到了一些参数:\n// 我是: zhangsan, 我收到了一些参数: 1\n\n// 我是: zhangsan, 我收到了一些参数:\n// 我是: zhangsan, 我收到了一些参数: 1, 2\n// 我是: zhangsan, 我收到了一些参数: 1, 2, 3, 4\n\n```\n\n\n\n\n\n参考文献：\n\n* [js原型中的this](https://www.jianshu.com/p/c0af837a6e23)","tags":["javascript"],"categories":["js"]},{"title":"代码可读性","url":"/2022/06/22/notes/代码可读性/","content":"> 对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率。代码的字里行间流淌的是软件生命中的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。       ——《阿里巴巴开发手册》\n\n<!-- more -->\n### 一致性\n\n不同开发者对同一事物会有不同的理解，因此对于关键业务名称的命名需要统一，使整个链路保持一致性。\n\n### 有意义且简短\n\n命名过长意味着该方法干的事太多，需要思考是否可以拆分方法，方法时候符合『单一职责』设计原则\n\n### 命名规范\n\n方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格。\n\n常量应全部大写，单词间用下划线隔开\n\n### 符合阅读习惯\n\n条件判断的时候优先判断异常情况提前返回。\n\n如果if中的条件表达式比较复杂，将复杂的条件表达式封装成一个函数，通过函数名来解释表达式的含义。也可以使用『策略模式』设计原则。\n\n\n\n好的代码重构原因：学习、集成、优化；\n\n差的代码重构原因：市场变化、需求变化、架构或设计问题、代码缺陷；\n\n\n\n","tags":["javascript"],"categories":["notes"]},{"title":"微信调整字体大小导致h5排版错乱问题解决方案","url":"/2022/05/23/wechat/wx-html/","content":"\n把下面代码放到合适位置，列如app.vue即可\n\niOS:\n\n```javascript\nbody {\n  -webkit-text-size-adjust: 100% !important;\n  text-size-adjust: 100% !important;\n  -moz-text-size-adjust: 100% !important;\n}\n```\n<!-- more -->\n\n\nAndroid:\n\n```javascript\nfunction handleFontSize() {\n  // 设置网页字体为默认大小\n  WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize' : 0 })\n  // 重写设置网页字体大小的事件\n  WeixinJSBridge.on('menu:setfont', function() {\n    WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize' : 0 })\n  })\n}\nif (typeof WeixinJSBridge === \"object\" && typeof WeixinJSBridge.invoke === \"function\") {\n  handleFontSize()\n} else {\n  document.addEventListener(\"WeixinJSBridgeReady\", handleFontSize, false)\n}\n```\n\n","tags":["wechat"],"categories":["wechat"]},{"title":"Vue源码之init","url":"/2022/04/10/vue/vue-init/","content":"#### 1.Vue\n\n```javascript\n// src/core/instance/index.js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n<!-- more -->\n首先定义一个构造函数`Vue`，执行`initMixin`、`stateMixin`等初始化方法；之后用户调用`new Vue()`就会实例化Vue且执行`_init`方法，下面看\\_init方法做了什么\n\n#### 2.initMixin\n\n```javascript\n// src/core/instance/init.js\n// 在initMixin时会给Vue的原型上添加_init方法\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n   \t...\n    \n    // 合并参数\n    vm.$options = mergeOptions(\n      resolveConstructorOptions(vm.constructor),\n      options || {},\n      vm\n    )\n    \n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    ...\n    \n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n\n可以看到，在`callHook`触发`beforeCreate`时候并没有`initState`，只是初始化了基础参数，所以在`beforeCreate`时候无法访问到data/method/computed/watch等方法","tags":["vue源码"],"categories":["vue"]},{"title":"new Vue()的过程","url":"/2022/03/10/vue/new Vue()/","content":"Vue: `vue@2.6.14`\n\n1. `'core/instance/index'`,定义`Vue`\n   * `initMixin`给Vue的原型定义`_init`\n     * `_init` 属性的初始化\n       * `mergeOptions`合并参数\n       * `initLifecycle`初始化挂载生命周期相关属性\n       * `initEvents`初始事件相关属性，当父组件绑定到子组件时，供子组件调用\n       * `initRender`初始化slot插槽\n       * `callHook(vm, 'beforeCreate')` 生命周期调用\n       * `initState` 初始化data/method/computed/watch\n       * `initProvide` 初始化provide\n       * `callHook(vm, 'created')` created生命周期调用\n       * `$mount` 调用mountComponent\n       <!-- more -->\n   * `stateMixin` 初始化dataDef，propsDef的get方法\n     * `Vue.prototype.$set = set` 挂载全局$set方法\n     * `Vue.prototype.$delete = del` 挂载全局$delete方法\n     * `Vue.prototype.$watch` 挂载全局$watch方法，createWatcher\n   * `eventsMixin` 初始化eventbus, 挂载`$on, $once, $emit, $off` 方法\n   * `lifecycleMixin` 初始化生命周期相关\n     * `Vue.prototype._update` 打补丁\\_\\_patch\\_\\_，更新数据\n     * `Vue.prototype.$forceUpdate` Vue 实例重新渲染方法\n     * `Vue.prototype.$destroy` 销毁\n     * `mountComponent` 挂载组件\n       * 编译template成render函数\n       * `callHook(vm, 'beforeMount')` 触发生命周期钩子\n       * `new Watcher(vm, updateComponent)` 监听vm，如果已经挂载且未销毁组件，则会触发钩子`callHook(vm, 'beforeUpdate')`\n       * `updateComponent` 更新数据，调用`_update`\n       * `callHook(vm, 'mounted')` 更新完毕数据后，触发生命周期钩子\n   * `renderMixin` 渲染DOM相关\n     * `Vue.prototype.$nextTick` 初始化nextTick方法\n     * `Vue.prototype._render` render方法\n\n\n\n### 生命周期\n\n![new Vue()](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202203081423948.png)\n\n","tags":["vue源码"],"categories":["vue"]},{"title":"小米T500电动牙刷更换电池","url":"/2022/02/10/notes/mi-T500/","content":"\n#### 更换材料准备\n\n* 14500锂电池(带镍片)\n* 螺丝刀\n* 焊接工具\n<!-- more -->\n\n![图一](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281405875.jpeg)\n\n> 小米T500使用的是一颗14500可充电锂电池(700mAh，图一下)，用了一年之后只能坚持两次就提示充电，只能着手更换电池(图一上，1000mAh替代电池)\n\n#### 拆解步骤\n\n1. T500整体光滑无从下手，拆机需从底部入手，最下面的垫片需要先取出来，取出后会露出固定螺丝。垫片比较难取，刚开始用的热熔胶，但是粘性不够，取不出来，之后尝试美工刀敲，但是缝隙太小没法搞，最后使用螺丝刀拧入一颗螺丝(开红酒的办法)取出来![img](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281419590.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg)\n\n2. 螺丝拧掉后，先把颜色环取掉,之后小心取掉尾部(尾部有电磁充电的线圈，暴力拆解有断掉风险，断掉需要重新焊接，问题不大)![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281408645.jpeg)\n\n3. 取掉尾部后，需要卡着下图两边的白色凸起，凸起部分是紧紧卡着桶壁的，使用镊子或者撬棒两边翘起一点，之后顶着头部就可以顶出来了，之后慢慢拖动把牙刷主体拿出来![尾部充电线圈](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281445076.JPG)\n\n4. 加热焊枪，融化正负极焊锡后吸锡器吸走，取出电池![牙刷主体](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281445817.JPG)\n\n5. 更换电池，把原有的正负极绝缘贴，贴到新电池上，焊接正负极镍片，开机测试![新电池焊接](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202202281447923.jpeg)\n\n6. 测试正常后按顺序装机即可，注意遮光罩，垫子等不要忘记还原\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["notes"]},{"title":"JavaScript语言精粹","url":"/2021/12/30/notes/JavaScript语言精粹/","content":"1. [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n![image](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112271513665.png)\n<!-- more -->\n2. 优先考虑使用.表示法，因为它更紧凑且可读性更好，但是如果你尝试检索一个不一定存在的值，则需使用['string']写法，它将返回一个`undefined`，若尝试从`undefined`的成员属性中取值，则会导致 TypeError 异常，这时可以通过`&&`运算符避免错误\n   ```javascript\n   const obj = {\n     name: 'zhangsan'\n   }\n   \n   obj.name // 'zhangsan'\n   obj['age'] // undefined\n   obj.hubby.name // throw 'TypeError'\n   obj.hubby && obj.hubby.name // undefiend\n   ```\n   \n3. `for in`语句可以遍历一个对象中的所有属性，该枚举过程将会列出所有的属性——包括函数和原型中的属性。所以通常可以使用`hasOwnProperty` 方法过滤。属性名的**出现顺序是不确定的**，如果你想要确保属性以特定顺序出现，最高的办法就是避免使用`for in`语句，而是创建一个数组，在其中以正确的顺序保函属性名。通过 for 而不是 for in，可以得到我们想要的属性，而不用担心可能发觉出原型链中的属性，并且我们按正确顺序取得了它们的值。\n\n   ```javascript\n   const obj = {.........}\n   const arr = [\n     'name',\n     'age',\n     'height',\n     'weight',\n     'hubby'\n   ]\n   arr.forEach(k => {\n   \tconsole.log(item + ': ' + obj[k])\n   })\n   ```\n\n4. 减少全局变量污染\n\n5. 闭包的好处是内部函数可以访问定义他们的外部函数的参数和变量(除了 this 和 arguments)，且内部函数拥有比外部函数更长的生命周期。\n\n6. 函数柯里化：1.参数复用；2.提前返回；3延迟计算/运行(bind就是个延迟执行的例子)\n\n7. 对象说明符：\n\n   ```javascript\n   // bad\n   const myObj = maker(a, b, c, d, e)\n   \n   // good\n   const myObj = maker({\n   \tfirst: a,\n     middle: b,\n   \tlast: c,\n     state: d,\n     city: e\n   })\n   // 现在多个参数可以按照任意顺序排列，如果maker函数接受参数使用默认值，那么一些参数也可以忽略调，并且代码也更容易阅读\n   ```\n   \n8. 伪类：当一个函数被创建时，新函数对象会被赋予一个`prototype`属性，他的值是一个包含`constructor`属性且属性值为该新函数的对象。`prototype`是存放继承特征的地方。当采用构造器调用模式，即用`new`前缀调用一个函数时，函数执行方式会被修改。构造器函数存在一个严重的危害，如果你在调用构造器函数时忘记加上`new`前缀，那么this将会绑定到全局对象上，造成不但没有扩充新对象，反而破坏了全局变量环境，所以构造器函数约定明明成首字母大写的形式(es6的class解决了这个问题，如果不用new调用，则会报错。es6的class可以看做是一个语法糖，他的绝大部分功能es5都可以做到，但是es6的class写法更加清晰、更像面对对象编程的语法)。\n\n9. 原型：一个新的对象可以继承一个旧对象的属性(`Object.creat(parentObj)`)。你可以通过构造一个有用的对象开始，接着构造更多的和那个对象类似的对象。这样可以完全避免把一个应用拆解成一系列嵌套抽象类的分类过程。\n\n10. 函数化：上面几种继承模式的一个弱点就是没法保护隐私(私有变量、私有函数)。如果对象的所有状态都是私有的，那么该对象就成为一个『防伪(tamper-proof)』对象。该对象的属性可以被替换或删除，但该对象的**完整性不会受到损害**。\n\n    ```javascript\n    const mammal = function (spec, my = {}) {\n      // my对象是一个为继承链中的构造器提供秘密共享的容器，my对象可以选择性使用\n      let _this\n      \n      _this = {}\n      // _this = new Object()\n      // _this = Object.creat({})\n    \n    \t// name和saying现在就是完全私有的，只能通过下面两个方法去访问它，无法从其他方式访问\n      _this.getName = function () {\n        return spec.name\n      }\n      _this.say = function () {\n    \t\treturn spec.saying || ''\n      }\n        \n      return _this\n    }\n    \n    const myMammal = mammal({ name: 'zhangsan' })\n    \n    // 创建cat继承他，我们的cat只需要关心自身差异\n    const cat = function (spec = 'meow') {\n      const _this = mammal(spec)\n      _this.xyz = function () {\n        return 'Hello World'\n      }\n      _this.getName = function () {\n        return 'aaaaaa==' + spec.name\n      }\n      return _this\n    }\n    \n    const myCat = cat({name: 'lisi'})\n    ```\n\n11. 正则尾部符号意义: g(global)/i(ignoreCase)/m(multiline)![image-20211229142706807](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112291427083.png)\n\n12. 用正则表达式字面量创建RegExp对象共享**同一个单利**：\n\n    ```javascript\n    // 字面量\n    function test () {\n    \treturn /a/gi\n    }\n    \n    const x = test()\n    const y = test()\n    \n    x.lastIndex = 10\n    console.log(y.lastIndex) // 10\n    \n    // new\n    function reg () {\n    \treturn new RegExp(a, 'gi')\n    }\n    \n    const x = reg()\n    const y = reg()\n    \n    x.lastIndex = 8\n    console.log(y.lastIndex) // 0\n    ```\n\n13. 除了控制字符和特殊字符外，所有的字符都会被按照字面处理，下列字符如果需要按照字面去匹配，那么必须要用一个`\\`前缀来进行转义。\n\n    ```javascript\n    \\ / [ ] ( ) { } ? + * | . ^ $\n    ```\n\n14. 正则表达式分组：\n\n    1. 捕获型(/([a-z])/)：任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第一个捕获(的分组是1，第二个捕获(的分组是2。(\\$1....$x)\n    2. 非捕获型(/(?:a)/)：非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本。这会带来**微弱的性能优势**。非捕获型分组不会干扰捕获型分组的编号。\n    3. 向前正向匹配(/(?=a)/)：它类似于非捕获型分组，但在这个组匹配后，文本会倒回到它开始的地方，实际上并不会匹配到任何东西。这不是一个好特性。\n    4. 向前负向匹配(/(?!a)/)：它类似于向前正向匹配分组，但只有当它匹配失败时它才回继续向前进行匹配。这不是一个好特性\n\n    ```javascript\n    \"abcabc\".match(/(a)(b)(c)/) // [\"abc\", \"a\", \"b\", \"c\"]\n    \"abcabc\".match(/(?:a)(b)(c)/) // [\"abc\", \"b\", \"c\"]\n    \n    '<div>'.match(/<(?=br>)/) // null\n    '<br>'.match(/<(?=br>)/) // [\"<\"]\n    \n    '<div>'.match(/<(?!br>)/) // [\"<\"]\n    '<br>'.match(/<(?!br>)/) // null\n    ```\n\n15. `regexp.exec()`是正则表达式最强大(也是最慢)的方法。如果它成功匹配`regexp`和字符串`string`，它会返回一个数组。数组下标0的元素将包含正则表达式regexp匹配的子字符串。下标1的元素是分组1捕获的文本，2的元素是分组2捕获的文本，以此类推。如果匹配失败，它会放回`null`。如果regexp带有一个g标识，`regexp.lastIndex`会被设置为该匹配后第一个字符的位置，不成功则会重置为0。\n\n16. `regexp.test()`是正则表达式最简单(也是最快)的方法。如果它匹配成功则会返回`true`，否则返回`false`。不要对这个方法使用g标识。\n\n17. 统一的代码风格....\n\n18. 毒瘤：\n\n    1. 全局变量\n    2. 自动插入分号\n\n19. 糟粕：\n\n    1. ==，隐式转换：\n       1. 对象和布尔值比较时，会先转换为字符串，在转换为数字\n       2. 对象和字符串比较时，对象转换为字符串，然后两者进行比较\n       3. 对象和数字比较时，对象转化为字符串,然后转换为数字，再和数字进行比较\n       4. 字符串和数字比较时，字符串转换为数字\n       5. 字符串和布尔值进行比较时，二者全部转换成数值再比较\n       6. 布尔值和数字进行比较时，布尔转换为数字\n\n    ```javascript\n    '' == 0 // true\n    [1,2,3] == '1,2,3' // true\n    '0' == false // true\n    [] == false // true\n    true == 1 // true\n    ```\n\n    1. with: js提供了with语句，本意是想用它来快捷的访问对象属性，不幸的是，他的结果有时不可预料\n    2. eval: eval传递一个字符串给js编译器，并执行其结果。使用eval会导致代码更加难以阅读，且导致性能显著降低，因为它需要运行编译器。eval函数减弱了程序的安全性，因为他给求值的文本太多权利，而且就像with语句执行方式一样，他降低了语言的性能\n    3. continue: 重构移除continue后，性能会得到改善\n    4. 缺少块的语句：貌似在做一件事，实际确实另一件事的程序是非常难理解清楚的。\n\n    ```javascript\n    if (a)\n      t = 1\n    \tfn()\n    \n    // 它看起来像是要这样:\n    if (a) {\n    \tt = 1\n      fn()\n    }\n    \n    // 实际上本意是\n    if (a) {\n    \tt = 1\n    }\n    fn()\n    ```\n\n    5. 位运算符：在java里，位运算符处理的是整数，ja没有整型，只有双精度浮点数。因此，位操作符把它们的数字运算数先转换成整数，接着执行运算，最后再换回去。再大多数语言中，这些位运算符接近于硬件处理，所以非常快，而js执行环境一般接触不到硬件，所以非常慢。\n\n    ```javascript\n    &\t\t\tand 按位与\n    |\t\t\tor  按位或\n    ^\t\t\txor 按位异或\n    ~\t\t\tnot 按位非\n    >>\t\t带符号右位移\n    >>>\t\t无符号又位移(用0补足)\n    <<\t\t左位移\n    ```\n","tags":["javascript"],"categories":["notes"]},{"title":"macOS 12 升级xcode 13后无法打开iOS11.4Simulator解决方法","url":"/2021/11/19/notes/macOS12-xcode13/","content":">macOS升级到12 macOS Monterey后，xcode(version 12)提示无法使用，需要升级，升级前还能打开iOS11.4的Simulator，升级后(xcode 13)提示不支持低版本iOS，最低支持iOS12版本，但是项目中又需要用到低版本的系统。\n<!-- more -->\n1. 首先确保xcode有安装iOS11.4的Simulator，若没有则需要`Xcode > Preferences > Components`下载需要的Simulator![模拟器版本](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171407668.png)\n2. 下载完毕后，打开finder，commond+shift+g快速前往Simulator安装目录`/Library/Developer/CoreSimulator/Profiles/Runtimes`，选中对应的模拟器版本右键显示包内容，找到`Info.plist`，拷贝到桌面一份![Info.plist](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171407086.png)\n3. 双击打开桌面的`Info.plist`，默认使用Xcode打开，找到Bundle identifier，修改值，在最后面加一个-1，使版本检查函数找不到对应的bundle name跳过检查，修改后复制桌面的文件回到原来的位置覆盖粘贴(此处可能需要验证权限)![iOS](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171407865.png)\n4. Terminal中输入`open -a Simulator`打开模拟器，选择`File > New Simulator`，点击Create就可以创建低版本Simulator了，如果没有自动打开Simulator，则手动选择`File > Open Simulator`找到iOS 11.4去打开![Simulator](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171407106.png)\n![iOS 11.4](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171408620.png)\n\n参考：https://hiraku.tw/2021/04/6428/","tags":["macOS","Xcode","Simulator"],"categories":["notes"]},{"title":"typec快速分离线","url":"/2021/10/15/notes/typec-line/","content":"#### 材料：\n\n* 航空插头\n* typec数据线\n* 电烙铁，焊锡、助焊剂等\n<!-- more -->\n#### 焊接要点：\n\n* 胆大心细，温度合适\n* 注意焊头不要长期高温空置，长期不用就调低温度，短期不用就注意及时挂锡\n* 要焊接的地方提前上锡，方便焊接\n* 焊接前可以点下松香，去掉氧化层再上锡\n\n#### 步骤：\n\n1. 简单粗暴，直接干断，电线芯剥一点露出铜线头，方便焊接\n![断点自己喜欢就好](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171409142.png)\n2. 铜线镀锡，防止焊接时候散开\n![镀锡](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171409132.png)\n3. 焊接两个点，记住焊接的点位，航插上有个防呆扣，方便记忆，线序焊错差上是不能用的\n![固定](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171409503.png)\n4. 点位焊接完毕，检查是否有虚焊\n![检查固定](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171409468.png)\n5. 焊接母头，操作跟上面一直，一定要确定线序对齐，一定要确定线序对齐，一定要确定线序对齐，保鲜膜绕线大法（线材质太硬，或者我操作有问题，失败了XD）\n![绕线](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410189.png)\n5. 上机检查，查看是否能用\n6. 检查完后开始注胶，灌注704胶或者热熔枪固定（热熔枪凝固太快，选择了704胶灌注）\n![注胶](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410506.png)\n7. 等待凝固后就可以正常用啦\n![成品](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410555.png)\n![成品](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410518.png)\n\n#### 撸键盘\n键盘就比较简单了，找一把带主控的pcb板子，直接插轴焊接轴脚，焊接键盘是个耐力活儿，不难但是多\n![pcb](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410985.jpeg)\n\n![这把键盘用的ttc青轴，声音清脆，手感不错](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171410300.jpeg)","categories":["notes"]},{"title":"xbb-utils开发规范","url":"/2021/08/15/notes/xbb-utils/","content":"为什么选择开发utils包？\n\n- 方便代码的快速维护\n- 方便一套代码部署多个项目以及新项目的快速启动\n- 为后期需求踩坑\n<!-- more -->\n为什么选择ts？\n\n- 有更加安全的静态类型检查，而静态类型检查更有利于构建大型项目\n- 增加了代码可读性\n- 更有好的IDE代码提示\n\n### 版本规范\n\n主版本号.子版本号.修正版本号\n\n修复bug：修正版本号+1\n\n新增方法：子版本号+1，修正版本号复位为 0\n\n整体影响：重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1，其余版本号复位为0\n\n|版本号|备注|\n|---|---|\n|v0.0.1|基础搭建|\n|v0.1.0|新增vue2.x调试页面|\n|v0.1.1|修复bug，完善单测|\n|v0.1.2|修复bug，维护更新|\n|v1.1.0|优化math方法，新增thumbnail, formatToNumber, dealNumber, getGuid方法|\n\n\n\n### 项目结构\n\n每个文件夹都有各自的职责，项目配置文件单独列出来方便修改配置。核心模块也就只有`src`文件，其余都是辅助。\n\n```JavaScript\n.\n├── LICENSE\n├── README.md\n├── babel.config.js\n├── coverage // 单测结果\n│   └── lcov-report\n│       └── index.html // 单测结果页面入口\n├── docs // typedoc生成的文档\n│   ├── assets\n│   ├── globals.html\n│   ├── index.html\n│   └── interfaces\n├── gulpfile.js // gulp+rollup配置文件\n├── package.json\n├── src // 代码模块\n│   ├── core // 核心代码块\n│   │   ├── env.ts\n│   │   └── **.ts\n│   ├── index.ts // 入口文件\n│   ├── tools\n│   │   └── index.ts // 工具\n│   └── types // 声明文件\n│       └── index.ts // interface\n├── tests // 单元测试\n│   └── unit // 核心测试模块\n├── home // vue调试页面\n│   └── ** // 调试\n├── vue.config.js // vue项目配置(调试用)\n├── jest.config.js // jest单测配置\n├── tsconfig.json // ts配置\n├── tslint.json // tslint配置\n├── .prettierrc // prettier配置\n├── .lintstagedrc // lintstage配置\n└── typedoc.json // typedoc配置\n\n```\n\n\n### src\n\n1. 所有功能模块需要开发到`src/core/**`下，此文件为核心代码块；\n2. 具体功能目前划分了几大类别`math` `url` `is` `method` `verify`...等等，后期按需添加；\n3. `core`下的方法都需要导出，且需要添加注释，注释参考下图(图1)，此描述不生成文档，故可以写的更加详细；\n4. `core/is.ts`为类型判断文件，推荐大家项目中需要进行类型判断时候使用此文件，而不是书写新的判断代码。\n5. `types`文件夹放interface接口声明，`interface`有几个大类对应`core`下的文件命(图2)，作为开发中的代码提示文案，interface的备注需要书写的清晰，传入的参数以及返回的参数类型一定要正确，文案也要相对简练。\n6. 类型超过3个(包含3个)推荐使用类型别名，例如：\n\t```TypeScript\n\t// bad\n\texport function checkType(val: Date | string | number): Date {\n\t  // TODO...\n\t}\n\t\n\t// good\n\ttype dateType = Date | string | number\n\texport function checkType(val: dateType): Date {\n\t  // TODO...\n\t}\n\t```\n\t\n\n备注：因为使用了自动文档生成工具，所以为了避免文档输出混乱，备注需要统一的规则。除`types`文件下的方法，其余的都需要添加`@ignore`阻止文档的自动生成，\n\n![图1](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047229.png)\n\n![图2](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047515.png)\n\n### 单测\n\n1. `unit/index.spec.ts`文件用来测试实例是否挂载了对应的方法(`/src/core/**.ts`)，每次在`core`下新增方法后，都需要到这个文件下的对应单测模块中添加测试实例，用于确保实例有此方法，相当于双重保险；\n2. `unit/core/**.spec.ts`为对应的`core`下的核心单测文件，每个单测方法都有一个大的`describe`包裹数个`it`，方便单测报错时，定位具体哪个文件下的哪个方法报错，错误日志会输出`describe`和`it`的描述文案；\n\t![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047549.png)\n3. 单测文件需要把要测试的代码中的每一个分支，每一行代码，每一个判断都要覆盖，需要完成方法覆盖100%，分支覆盖98%，行数覆盖100%的条件，推荐全部100%；\n\t![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047925.png)\n4. 单测结果可以在控制台或者`coverage/lcov-report/index.html`查看详情。\n\t![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047418.png)\n\t- 第一行10x 代表当前行走了10次\n\t- 黄色img[0]表示单测这行代码没有覆盖到\n\t- `if`前的E标识，说明此`if`判断的`else`条件没有覆盖\n\t- 红色则表示整行(大段代码)没有覆盖到，考虑是否漏写该方法的单测\n\n### 调试\n\n本项目为了方便调试，已集成vue2.x，可以通过`npm run serve`启动vue项目。\n\nvue项目目录为`home/*`。\n\n### 使用\n\n需要用到的项目，使用`npm i -S xbb-utils`来安装最新版本，之后再需要用到的页面`import xbb from 'xbb-utils'`\n\n![代码提示](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047096.png)\n\n### 功能开发\n\n1. 首先需要基于远端master拉取最新代码分支\n2. 新建开发分支，一般为feature/开发分支名的格式`git checkout -b feature/xxxxx`\n3. 推送开发分支到远端并追踪关系`git push --set-upstream origin feature/xxxxx`\n4. enjoy your coding...\n\nps: 如果有好的点子但是没有时间开发，可以再gitlab提交issues\n\n### 开发完成\n\n1. 开发完成后需要再跑一遍单测，确保通过率为100%\n2. 检查无误，没有问题之后，去gitlab提交MR(merge request)\n3. 待管理员审核无误后发布，会在群里通知最新版本号，及时更新到最近版本即可\n\n\n\n","tags":["typescript","jest","npm","vue2","git","vue"],"categories":["notes"]},{"title":"内存泄漏排查","url":"/2021/08/10/vue/memory/","content":"### 前言\n\n目前web端在浏览器中操作时，会存在明显的卡顿，而且会越用越卡，初步怀疑是内存泄漏导致。\n\n<!-- more -->\n\n### 问题排查\n\n#### 1. 不断重复打开、关闭页面，发现内存一直在增加；\n\n\n\n初始内存占用：\n\n![img](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202207061659725.png)\n\n\n\n\n\n一顿操作之后：\n\n![img](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202207061658631.png)\n\n\n\n排查占用内存较大的数据点：\n\n![img](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202207061658627.png)\n\n\n\n\n\n#### 2.图表中心来回切换不同图表，会有内存增加情况\n\n可能原因：\n\n1. 页面中有添加自定义的监听事件，但是销毁时没有移除事件\n2. echarts在组件销毁的时候可能没有清除引用，组件销毁时需要调用dispose销毁实例\n\n\n\n\n\n关于内存泄漏的排查方法可参考下面的文章：\n\n1. https://zhuanlan.zhihu.com/p/26269860\n2. https://zhuanlan.zhihu.com/p/67843006\n3. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management\n\n","tags":["vue","memory"],"categories":["vue"]},{"title":"input超过10^20科学记数法的解决方案","url":"/2020/11/13/js/input超过10^20科学记数法的解决方案/","content":">项目中用到input type=\"number\" 输入框如果数值超过了10的20次方会显示成10exxx或者10e+xxx \n>解决方案：\n>1.说服产品，一般情况下不会存在大于10的20次方或者小于是的负10次方的值\n>2.转换成字符串形式展示\n\n网上找的不是这个不匹配就是那个结果不对，那干脆自己写个好了\n<!-- more -->\n```javascript\nfunction ScientificNumber (num) {\n    if (!num) return num\n    const str = num.toString()\n    const reg = /^(\\d+)(\\.\\d+)?(e)([+]?\\d+)$/\n    const reg2 = /^(\\d+)(\\.\\d+)?(e)([-]?\\d+)$/\n    let arr\n    let len\n    let zero = ''\n    if (reg.test(str)) {\n      arr = reg.exec(str)\n      // 保留小数位数\n      const arr2 = arr[2] ? arr[2].replace('.', '') : ''\n      // 此处减去arr2的长度为了兼容有小数情况\n      len = Math.abs(arr[4]) - (arr2.length || 0)\n      for (var i = 0; i < len; i++) {\n        zero += '0'\n      }\n      return arr[1] + arr2 + zero\n    } else if (reg2.test(str)) {\n      arr = reg2.exec(str)\n      len = Math.abs(arr[4]) - 1\n      const arr2 = arr[2] ? arr[2].replace('.', '') : ''\n      for (let index = 0; index < len; index++) {\n        zero += '0'\n      }\n      return '0.' + zero + arr[1] + arr2\n    } else {\n      return num\n    }\n  }\n```\n\n![测试结果](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171510537.png)","tags":["javascript","input"],"categories":["js"]},{"title":"回调与异步编程","url":"/2020/08/07/js/event-loop/","content":"\n#### 一、回调函数的使用场景\n\n1. 异步编程。\n2. 事件监听、处理。\n3. setTimeout、setInterval方法。\n4. 通用功能，简化逻辑。\n<!-- more -->\n#### 二、异步编程的4种方法\n\n1. 回调函数。\n2. 事件监听。\n3. 发布订阅。\n4. Promise对象。\n\n\n\n回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段代码。\n\n```javascript\nfn1(fn2)\nfunction fn1 () {\n  // to do...\n  fn2()\n}\n\nfunction fn2 () {\n  // to do...\n}\n```\n\n\n\n说到异步编程，那么就有必要了解js的事件循环机制Event Loop\n\n![image.png](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171427632.png)\n\n#### 1. 栈和队列\n\n![image.png](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171427417.png)\n\n栈：    后进先出（LIFO-last in first out）:最后插入的元素最先出来。\n\n队列：先进先出（FIFO-first in first out）:最先插入的元素最先出来。\n\n#### 2. 宏任务和微任务(浏览器)\n\n宏队列，macrotask。一些异步任务的回调会依次进入macro task queue，等待后续被调用：\n\n- setTimeout和setInterval\n- requestAnimationFrame\n- I/O\n- UI rendering\n\n微队列，microtask。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用：\n\n- Promise.then\n- Object.observe\n- MutationObserver\n\n执行顺序：\n\n1. 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等），遇到异步代码根据上述任务划分到对应队列中；\n2. 全局Script代码执行完毕后，调用栈Stack会清空；\n3. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n4. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。（即清空微任务队列，注意：如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行）\n5. microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n6. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n7. 执行完毕后，调用栈Stack为空；\n8. 重复第3-7个步骤；\n9. ...\n\n简单来说，执行主线程同步代码遇到异步任务挂起划分到对应任务队列，主线程同步代码执行完毕后，清空微任务队列，此时微任务清空，执行栈清空，开始执行宏任务，执行完一个宏任务后查看微任务队列并执行清空，之后继续执行宏任务依次循环。\n\n概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了:\n\n```javascript\nconsole.log(1)\n\nsetTimeout(() => {\n  console.log(2)\n  Promise.resolve().then(() => {\n    console.log(3)\n  })\n})\n\nnew Promise((resolve, reject) => {\n  console.log(4)\n  resolve(5)\n}).then(data => {\n  console.log(data)\n  return 6\n}).then(data => {\n  console.log(data)\n})\n\nsetTimeout(() => {\n  console.log(7)\n  Promise.resolve().then(() => {\n    console.log(8)\n  })\n})\n\nconsole.log(9)\n```\n\n","tags":["javascript","event loop"],"categories":["js"]},{"title":"前端数据存储之IndexedDB","url":"/2020/08/06/js/indexedDB/","content":"\n##### 一、关于前端数据存储常用的几个方案\n\n1. Cookie\n2. Web Storage\n3. IndexDB\n<!-- more -->\n##### 二、cookie和storage差异对比\n\n|   特点   |                      Cookie                      |                         Web Storage                          |                           IndexDB                            |\n| :------: | :----------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 生命周期 |           可设置过期时间或跟随当前页面           |      localStorage: 永久有效sessionStorage: 跟随当前页面      |            永久有效，除非手动清除，同localStorage            |\n| 数据大小 |                        4k                        |                            一般5m                            |                    取决于硬盘的大小的50%                     |\n|   局限   | 每次请求都会携带到header中，使请求数据无意义增大 | 对于Object类型数据必须json序列化才能储存，且是同步操作，大数据操作会阻塞进程 | 若磁盘满，最近最少使用的源将首先被删除，然后是下一个，直到浏览器不再超过限制。 |\n\n##### 三、IndexDB特点\n\n1. **键值对储存。**IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n2. **异步。** IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，锁死用户操作。\n3. **支持事务。** IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况，操作数据更安全。\n4. **支持索引。** IndexedDB 数据表可以建立索引，索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。\n5. **同源限制。** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n6. **储存空间大。** IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，大小一般是硬盘大小的50%，超过就会触发源回收。\n7. **支持二进制储存。** IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n##### 四、IndexDB用法\n\nIndexDB已经被封装抽离成一个个的API，所以使用时可以直接调用浏览器API。\n\n新建数据库，open方法接收两个参数 一个是数据库名字 第二个是版本号，整数，默认为1或当前版本\n\n若没有对应库名的数据库则会进行新建数据库操作\n\nopen方法返回一个IDBRequest对象，对象通过**error、success、upgradeneeded**，处理打开数据库的操作结果\n\n```javascript\nlet request = window.indexedDB.open(databaseName, version)\nlet db\n\nrequest.onerror = (event) => {\n  console.log('数据库打开报错', event)\n}\n\nrequest.onsuccess = () => {\n  db = request.result\n  console.log('数据库打开成功', db)\n}\n\nrequest.onupgradeneeded = ({ target: { result } }) => {\n  // changing objectStore data is done here, as opposed to a transaction enum:\n  db = result\n  console.log('数据库升级', db)\n}\n```\n\n![1](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/MeYVOLxGWMYAOpz2/img/66cc1241-764f-49f5-ba5c-f03599eb3a3e.png)\n\n现在，我们新建了一个名字叫做demoBase的数据库，那么光有数据库是不够的，我们还需要新建对象仓库(object store)类似于MySQL的表\n\n> 要创建一个对象仓库必须在upgradeneeded事件中，而upgradeneeded事件只会在版本号更新的时候触发，这是因为IndexedDB API中不允许数据库中的数据仓库在同一版本中发送变化\n\n```javascript\n// changing objectStore data is done here, as opposed to a transaction enum:\nrequest.onupgradeneeded = function ({ target: { result } }) {\n  console.log('数据库升级', result)\n  db = result\n  let objStore\n  // Node.contains()返回的是一个boolean，来表示传入的节点是否为该节点的后代节点。\n  // 判断是否有person对象仓库 若没有则新建一个对象仓库(即新建表)\n  if (!db.objectStoreNames.contains('person')) {\n    /**\n     * 新建person表 主键(key)是默认建立的索引，比如下面我们使用id做为主键\n     * @param name: string\n     * @param optionalParameters?: IDBIndexParameters\n     * keyPath\n     * autoIncrement\n    */\n     objStore = db.createObjectStore('person', { keyPath: 'id' })\n    /**\n     * 创建索引 用于快速检索\n     * @param name: string\n     * @param keyPath: string | string[]\n     * @param optionalParameters?: IDBIndexParameters\n    */\n    objStore.createIndex('nameIndex', 'name', { unique: false })\n  }\n}\n```\n\n现在，数据库和表我们都有了，那么下一步就是操作表，也就是增、删、改、查数据，我们需要通过事务来操作\n\n>一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含了两个以上目的\n>1、为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍然保持一致性的方法\n>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作相互干扰\n\n1. 增\n\n   新增数据，首先需要新建一个事务，新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）\n\n   ```javascript\n   function add() {\n     let content = db.transaction(['person'], 'readwrite')\n     \t.objectStore('person')\n     \t.add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n   \n     content.onsuccess = (event) => {\n       console.log('数据写入成功')\n     }\n   \n     content.onerror = (event) => {\n       console.log('数据写入失败')\n     }\n   }\n   ```\n\n   此时一条数据已经新增成功我们可以打开Chrome DevTools，关于数据存储可以打开Application再Storage中找到IndexDB\n\n2. 删\n\n   ```javascript\n   function remove() {\n     const request = db.transaction(['person'], 'readwrite')\n       .objectStore('person')\n       .delete(1)\n   \n     request.onsuccess = (event) => {\n       console.log('数据删除成功')\n     }\n   \n     request.onerror = (event) => {\n       console.log('数据删除失败')\n     }\n   }\n   ```\n\n   \n\n3. 改\n\n   ```javascript\n   function update () {\n     const request = db.transaction(['person'], 'readwrite')\n       .objectStore('person')\n       .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' })\n   \n     request.onsuccess = (event) => {\n       console.log('数据更新成功')\n     }\n   \n     request.onerror = (event) => {\n       console.log('数据更新失败')\n     }\n   }\n   ```\n\n   \n\n4. 查\n\n   ```javascript\n   function search () {\n     // 新建查询事务\n     const request = db.transaction(['person'])\n       .objectStore('person')\n   \t\t// 查询主键是1的  \n       .get(1)\n     \t// 通过索引查\n     \t// .index('name')\n       // .get('李四')\n   \n     request.onsuccess = (event) => {\n       if (request.result) {\n         console.log('data===', request.result)\n       } else {\n         console.log('未获得数据记录')\n       }\n     }\n     \n     request.onerror = (event) => {\n       console.log('事务失败')\n     }\n   }\n   ```\n\n##### 五、简单封装使用\n\n```javascript\nclass IndexDBDemo {\n  db = null\n\n  constructor(name, storeOpt = {}, key = null, indexOpt = {}) {\n    if (!this.db) {\n      this.init(name, storeOpt, key, indexOpt)\n    }\n    return this.db\n  }\n\n\t// 初始化\n  init (name, storeOpt = {}, key = null, indexOpt = {}) {\n    console.log('init')\n    const request = indexedDB.open(name)\n\n    return new Promise((res, reject) => {\n      request.onsuccess = () => {\n        this.db = request.result\n      }\n  \n      request.onupgradeneeded = function ({ target: { result } }) {\n        this.db = result\n        if (!this.db.objectStoreNames.contains(name)) {\n          const req = this.db.createObjectStore(name, storeOpt)\n          if (key) {\n            req.createIndex(key, key, indexOpt)\n          }\n        }\n        res()\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  add (name, data) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .add(data)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  remove(name, key) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .delete(key)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  update (name, data) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name], 'readwrite')\n        .objectStore(name)\n        .put(data)\n\n      request.onsuccess = (event) => {\n        result(event)\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n\n  search (name, index) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name])\n        .objectStore(name)\n        .get(index)\n\n      request.onsuccess = (event) => {\n        if (request.result) {\n          result(request.result)\n        } else {\n          console.log('no data')\n          reject()\n        }\n      }\n\n      request.onerror = (error) => {\n        console.log('事务失败')\n        reject(error)\n      }\n    })\n  }\n\n  searchIndex(name, key, index) {\n    return new Promise((result, reject) => {\n      const request = this.db.transaction([name])\n        .objectStore(name)\n        .index(key)\n        .get(index)\n\n      request.onsuccess = (event) => {\n        if (request.result) {\n          result(request.result)\n        } else {\n          console.log('no data')\n          reject()\n        }\n      }\n\n      request.onerror = (error) => {\n        reject(error)\n      }\n    })\n  }\n}\n\n// 使用\nthis.db = new IndexDBDemo(name, { keyPath: 'id', autoIncrement: true }, 'name', { unique: false })\nthis.db.add(name, obj).then().catch()\nthis.db.remove(name, key).then().catch()\nthis.db.update(name, obj).then().catch()\nthis.db.search(name, key).then().catch()\nthis.db.searchIndex(name, '索引', '索引值').then().catch()\n\n```\n\n\n\n##### 六、浏览器兼容\n\n更多高级用法参考[Web API](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API#Browser_compatibility) \n\n功能再强大，不兼容也不行，下面是浏览器兼容图，数据来源 [can i use](https://caniuse.com/#search=IndexDB)\n\n![浏览器兼容情况](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221109134.png)","tags":["javascript","cookie","indexedDB","localStorage","sessionStorage"],"categories":["js"]},{"title":"Typescript+verdaccio+pm2构建私有工具包","url":"/2020/04/14/npm/Typescript+verdaccio/","content":"### 前言\n1. 项目中经常会用到某些方法，比如格式化时间戳，比如判断环境等等。  \n笔者最初是把这些方法抽离出来写成公共方法，但由于后期项目扩展每次都要复制这个工具文件很是麻烦且效率低下，发布npm包正好解决了这个痛点，正好借此机会重构成ts文件并发布npm包。  \n\n2. 本工具内置`vue2.x + ts`，方便开发中调试代码。  \n本工具包内部集成了`lodash`的一些方法，详见[文档](https://bestjarvan.github.io/utils-tools/docs/interfaces/lodashtool.html)或者`src/core/lodash-tool`  \n\n3. 本工具使用`typedoc`根据注释自动生成文档，可搜索方法\n\n4. 本项目npm包单元测试通过率100%，同时经过公司多个项目沉淀，且稳定运行，大家如有需要可直接下载拓展使用\n\n[博客传送门](https://bestjarvan.gitee.io/2020/04/14/npm/Typescript+verdaccio/index.html)\n\n本文只简要介绍下整个流程，具体项目[GitHub](https://github.com/BestJarvan/utils-tools)，欢迎Start、Fork。thx~   XD\n\n<!-- more -->\n\n### 简要\n\n- 工具\n- 项目架构\n- 初始化\n- 单元测试\n- 文档输出\n- 打包\n- 发布\n\n### 工具\n- [TypeScript](https://www.tslang.cn/)\n- [Typedoc](http://typedoc.org/)\n- [Vue 2.x](https://cn.vuejs.org/)\n- [Rollup](https://www.rollupjs.com/) + [gulp](https://www.gulpjs.com.cn/)\n- [jest](https://jestjs.io/)\n- [pm2](https://pm2.keymetrics.io/) + [verdaccio](https://verdaccio.org/)\n- [Lodash](https://www.lodashjs.com/)\n\n### 插件\n> 本工具包使用下列插件规范开发，定制团队开发规范\n- eslint\n- tslint\n- prettier\n- commitlint\n- husky\n\n### 项目架构\n\n```纯文本\n.\n├── LICENSE\n├── README.md\n├── docs // typedoc生成的文档\n│   ├── assets\n│   ├── globals.html\n│   ├── index.html\n│   └── interfaces\n├── gulpfile.js // gulp+rollup配置文件\n├── package.json\n├── public // vue相关\n├── home // vue调试页面\n├── src // 代码模块\n│   ├── core // 核心代码块\n│   │   ├── env.ts\n│   │   └── ***.ts\n│   ├── index.ts // 入口文件\n│   ├── tools\n│   │   └── index.ts\n│   └── types // 声明文件\n│       └── index.ts\n├── test // 单元测试\n│   ├── core // 核心代码单元测试\n│   │   ├── env.spec.ts\n│   │   └── ***.spec.ts\n│   └── index.spec.ts\n├── tsconfig.json // ts配置\n├── tslint.json // tslint配置\n├── .prettierrc // prettier配置\n├── .lintstagedrc // lintstage配置\n└── typedoc.json // typedoc配置\n```\n\n\n### 初始化\n\n1. `npm init`初始化项目\n2. 安装依赖`npm i -D gulp del typescript`\n3. 安装[rollup](https://www.rollupjs.com/guide/tools#gulp)依赖`npm i -D rollup rollup-plugin-node-resolve rollup-plugin-commonjs rollup-plugin-typescript2 rollup-plugin-uglify rollup-plugin-sourcemaps rollup-plugin-json`\n4. 安装辅助插件`npm i -D typedoc jest @types/jest ts-jest`\n5. 在项目中新建一个src文件，编写公共文件\n6. 需要一个types文件夹存放声明文件(用于代码提示)\n7. 所有文件都需要通过src/index.ts 对外抛出\n\n```纯文本\n// gulpfile.js\nconst gulp = require('gulp')\nconst del = require('del')\nconst rollup = require('rollup')\nconst json = require('rollup-plugin-json')\nconst commonjs = require('rollup-plugin-commonjs')\nconst resolve = require('rollup-plugin-node-resolve')\nconst sourceMaps = require('rollup-plugin-sourcemaps')\nconst typescript = require('rollup-plugin-typescript2')\nconst uglify = require('rollup-plugin-uglify').uglify\nconst pkg = require('./package.json')\n\n// 删除打包后的文件 目的为了每次打包出来的结果更干净，避免某些文件没被删除等原因抛错\nfunction task_clean (done) {\n  del.sync('dist')\n  del.sync('docs')\n  done()\n}\n\nasync function task_ts () {\n  const bundle = await rollup.rollup({\n    input: 'src/index.ts',\n    plugins: [\n      json(),\n      // Compile TypeScript files\n      typescript({ useTsconfigDeclarationDir: true }),\n      // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs)\n      commonjs(),\n      // Allow node_modules resolution, so you can use 'external' to control\n      // which external modules to include in the bundle\n      // https://github.com/rollup/rollup-plugin-node-resolve#usage\n      resolve(),\n  \n      // Resolve source maps to the original source\n      sourceMaps(),\n      uglify(),\n    ]\n  });\n\n  await bundle.write({\n    file: pkg.main,\n    format: 'umd',\n    name: pkg.name,\n    sourcemap: false\n  })\n}\n\ngulp.task('default',\n  gulp.parallel(\n    task_clean,\n    task_ts\n  )\n)\n```\n\n\n### 单元测试\n\n配置代码通过率最低标准\n例如我配置的 必须全部分支、方法、代码行数通过率达到90%才算测试通过\n\n```纯文本\n  coverageThreshold: {\n    global: {\n      branches: 90,\n      functions: 90,\n      lines: 90,\n      statements: -5\n    }\n  }\n```\n\n\n`jest --coverage // 生成测试覆盖率`<br />\n\n![测试结果](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509157.png)\n\n\n### 文档输出\n\n1. 配置typedoc\n\n```纯文本\n// package.json  scripts片段\n{\n  \"build\": \"npm run lint && gulp && typedoc\",\n}\n// tslint\n// gulp 会自动识别根目录下gulpfile.js配置文件\n// typedoc 自动识别根目录下typedoc.json配置文件\n// 参考项目结构\n```\n\n\n1. build后就可以提交到git服务器，比如我用的gitee使用gitee pages（静态页面托管，免去自己申请域名、服务器、虚拟主机等，github有github pages等）\n2. gitee pages简单的设置下入口文件(比如docs/index.html)就会生产对应的在线文档链接\n3. 使用 git hooks搭配 lint-staged 在提交时先去格式化暂存区代码，保持代码干净之后push代码\n\n![gitee pages](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509630.png)\n\n\n### 打包\n\n使用rollup配合gulp打包编译\n\n1. gulp配置中使用del删除dist文件，避免其他意外问题\n2. 使用rollup编译ts文件\n3. 编译后会保留声明文件，在package.json中typings字段写入汇总的声明文件地址，用于代码提示\n4. 丑化压缩js文件\n5. 输出到package.json定义的入口文件dist/index.js\n\n### 发布\n\n一、发布到npm市场\n\n1. 需要先在terminal登录npm\n2. 手动修改package.json的version(后期脚本自动更新)，npm publish，成功后会得到一个版本信息\n\n```纯文本\n+ @jarvannnn/utils@0.0.1\n```\n\n\n1. npm i --save @jarvannnn/utils 就可以项目中使用了\n\n二、使用verdaccio搭建npm私服，并使用pm2守护进程\n\n1. `npm install -g verdaccio pm2`全局安装verdaccio以及pm2[^pm2]\n2. terminal直接输入verdaccio \n即可立即运行，默认抛出端口为4873，我们可以使用`pm2 start verdaccio`指令使其运行到后台\n3. 现在我们可以通过`localhost:4873`访问npm私服^localhost\n4. 发布到verdaccio平台 首先需要在terminal中输入`npm adduser --registry http://localhost:4873`注册用户，输入用户名、密码、邮箱等信息注册\n5. `npm publish --registry http://localhost:4873` 发布代码包\n\ntips: 如果跟我一样不喜欢每次发布都要输入--registry，那么可以借助nrm[^nrm]镜像源管理工具来管理本地源\n\n### 项目中使用\n\n![代码提示](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509895.png)\n\n![代码提示](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509773.png)\n\n[^pm2]:  * `pm2 start verdaccio` 启动verdaccio<br />* `pm2 stop verdaccio(all) ` 停掉verdaccio(或全部)<br />* `pm2 delete verdaccio` 删除verdaccio<br />* `pm2 show verdaccio` 显示verdaccio运行日志\n\n[^nrm]: * `nrm add mynpm http://localhost:4873` 添加本地源<br />* `nrm use mynpm` 切换本地源<br />* `nrm ls` 查看本地所有源\n\n","tags":["typescript","jest","npm","verdaccio","rollup","pm2","typedoc"],"categories":["npm"]},{"title":"npm私有平台发布流程","url":"/2019/12/15/npm/npm-publish/","content":"### 一、源管理工具nrm\n\n1. 全局安装`npm i -g nrm`\n2. 添加逍邦源`nrm add xbb http://npm.xbongbong.com.cn/`\n3. 选择源`nrm use xbb`\n4. 添加用户到我们的源`npm adduser`，按照提示输入`username`,`password`,`email`参数\n<!-- more -->\n备注：若不使用nrm源管理工具，则每项npm命令都需要加入\n\n`--registry http://npm.xbongbong.com.cn/`\n\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221046249.png)\n\n### 二、发布npm包\n\n1. 进入到项目，例如xbb-utils，`cd ./xbb-utils`\n2. 登录刚刚注册的用户`npm login`，跟着操作\n3. 检查是否登录成功`npm whoami`，如果输出刚刚登录的用户名，说明登录成功了\n4. 发布到私有平台`npm publish`\n5. 如果发布的包有问题，撤销发布`npm unpublish`\n\ntips：~ * ^ 和无前缀的区别\n\n- ~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0\n- ^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0\n- * 这意味着安装最新版本的依赖包\n- 不写前缀——锁版本，比如1.2.3只会下载1.2.3版本代码，若没有对应版本则会下载失败\n\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047766.png)\n\n### 三、私有平台\n\n我们可以打开浏览器输入[http://npm.xbongbong.com.cn](http://npm.xbongbong.com.cn)，查看我们刚刚发布的包。\n\n私有平台已配置上游源，淘宝源和npm官方源，所以可以放心使用，找不到的包会现在淘宝源找，没找到再去官方源找。\n\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202112221047705.png)\n\n","tags":["npm","nrm"],"categories":["npm"]},{"title":"通过shell脚本自动生成vue文件","url":"/2019/08/10/vue/shell-vue/","content":"最近在写nuxt项目时候每次新建页面都要去新建然后引入各种需要的依赖很是麻烦，所以想写一个脚本自动生成文件 省去手动新建\n现写下实现方法 给大家参考\n<!-- more -->\n>Mac下可直接运行 \n>Windows下需要安装Cygwin类软件且配置环境变量后运行\n\n#使用方法\n1. 需要修改package.json 的scrpts 加一条create 或者自定义名字 主要是为了我们在terminal中输入指令后运行对应的脚本\n\n![package.json](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171443157.png)\n\n2. 在项目根目录新建一个template文件夹放自己的模板文件\n   文件内容根据项目需要自行修改\n\n![模板](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171443159.png)\n\n3. 之后在build文件夹下新建 create.sh 脚本文件 (代码在下面)\n\n4. 之后在terminal中输入 npm run create 指令 这个指令支持 后面携带一个不必传参数作为文件名 (npm run create xxxx)  或者直接输入npm run create\n\n![效果](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171444961.gif)\n\n文件名不能重复 如果重复不会覆盖原有文件 只会输出错误\n![名称重复](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171444987.gif)\n\n5. 生成后的文件以及文件内容\n![生成后的文件](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171444727.png)\n\n#create.sh 脚本文件\n修改```COMPONENT_PATH``` 和 ```PAGE_PATH ``` 路径改变为自己真实模板路径\n运行该脚本后\n组件会在```components```文件夹下新建组件\n页面会在```pages``` 文件夹下新建页面\n```Shell\n#!/usr/bin/env sh\ncreate () {\n  if [[ $REPLY =~ ^[Yy]$ ]]\n    then\n      PATH_DIR=\"./components/$NAME\"\n    else\n      PATH_DIR=\"./pages/$NAME\"\n    fi\n\n  if [ ! -d \"$PATH_DIR\" ]\n  then\n    mkdir $PATH_DIR\n    if [[ $PATH_DIR =~ \"components\" ]]\n    then\n      CLASS_NAME=\"component-$NAME\"\n      cp $COMPONENT_PATH \"$PATH_DIR/index.vue\"\n    else\n      CLASS_NAME=\"page-$NAME\"\n      cp $PAGE_PATH \"$PATH_DIR/index.vue\"\n    fi\n    sed -i \"\" \"s/class-name/$CLASS_NAME/\" \"$PATH_DIR/index.vue\"\n    echo -e \"\\n生成完成 \\n... \\n\"\n  else\n    echo -e \"\\n已存在文件夹 \\n$PATH_DIR\"\n  fi\n}\n\nset -e\necho \"开始生成代码...\"\nCOMPONENT_PATH=\"./template/component.vue\"\nPAGE_PATH=\"./template/page.vue\"\nif [[ -n $1 ]]\nthen\n  NAME=$1\n  read -p \"请问代码 $NAME - 是否是组件 ? (y/n)\" -n 1 -r\nelse\n  echo \"未发现名称, 请输入名称？\"\n  read NAME\n  read -p \"请问代码 $NAME - 是否是组件 ? (y/n)\" -n 1 -r\nfi\n  create\n```\n\n\n##模板组件参考\n```\n<template>\n  <div class=\"class-\">\n    component\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  data() {\n    return {}\n  },\n  methods: {\n    init() {}\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/common/scss/var.scss';\n@import '@/common/scss/mixin.scss';\n\n.class- {\n}\n</style>\n\n```\n##模板页面参考\n```\n<template>\n  <div class=\"class-\">\n    page\n  </div>\n</template>\n\n<script>\nimport { baseMixin } from '@/common/mixins/index'\n\nexport default {\n  mixins: [baseMixin],\n  data() {\n    return {}\n  },\n  async asyncData({ $axios }) {},\n  head() {\n    return {\n      title: ''\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {}\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/common/scss/var.scss';\n@import '@/common/scss/mixin.scss';\n\n.class- {\n}\n</style>\n```","tags":["shell","vue"],"categories":["vue"]},{"title":"ionic2拖拽元素","url":"/2018/06/20/ionic2/ionic2-jq/","content":"先看效果图\n![拖拽元素](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171507697.gif)\n<!-- more -->\n1、这里用到了jq 所以第一步我们在index 中引入 两个必须的jq\n```\n  <script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>\n  <script type=\"text/javascript\" src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n```\n\n2、第二步 我们需要在typings.d.ts中声明 $ 和 jQuery 这样才能在ts中使用这个方法\n```\ndeclare var $: any;\ndeclare var jQuery: any;\n```\n\n3、接着我们需要 引入 touchPunch.ts 这个文件 这是jq的触摸插件 jq封装好的可以直接用 ，下载之后放到某个文件夹下\n下载地址：https://gitee.com/bestjarvan/public/blob/master/mini-program-components/drag/touchPunch.ts\n\n4、放好后 我们引入app.module.ts 中 在providers中声明\n```\nproviders:[\n    TouchPunchProvider\n]\n```\n\n5、在html元素中 给需要拖拽的元素一个id 之后在ts中初始化一下我们的jq插件 就可以了\n```\n// 参考\n// html\n<ion-fab style=\"width: 5rem;height: 5rem;\" middle right #barrage id=\"barrage\">\n  <div ion-fab style=\"display: none\"></div>\n  <img src=\"./assets/images/picdetail_service.png\">\n</ion-fab>\n\n//ts\nconstructor(public touchIt:TouchPunchProvider){}\n\nionViewDidLoad() {\n  this.touchIt.init();\n  $('#barrage').draggable();\n}\n```\n完结","tags":["ionic2","angular","jquery"],"categories":["ionic2"]},{"title":"星星评价小程序、网页通用","url":"/2018/06/14/wechat/wx-star/","content":"先看效果图\n![效果图](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171507056.gif)\n<!-- more -->\n原理是需要两张图片 一张选中的黄色，一张未选中的灰色\n![选中](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171508974.png)\n\n![未选中](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171508245.png)\n\n1、循环image标签五次\n2、绑定点击事件\n3、获取点击下标，并赋值给score变量 \n4、三目运算判断score变量于index 的关系 动态更改图片路径\n5、此方法网页也可用 通用\n```\n//wxml\n<image class=\"start\" \n        wx:for=\"{{5}}\" \n        data-index=\"{{index}}\"\n        bindtap='selectIndexNum' \n        src=\"{{score >= index ? '/utils/img/big_star_s@3x.png' : '/utils/img/big_star_n@3x.png'}}\"\n/>\n\n//普通版本 js\nselectIndexNum(e){\n  this.setData({\n    score: +e.currentTarget.dataset.index\n  })\n},\n```\n或者增强版效果\n```\n//点两次相同分数取消选择 js\nselectIndexNum(e){\n  const i = +e.currentTarget.dataset.index;\n  this.setData({\n    score: i === this.data.score ? -1 : i\n  })\n},\n```","tags":["wechat"],"categories":["wechat"]},{"title":"记录下小程序项目中的一些问题","url":"/2018/06/08/wechat/wx-problem/","content":"项目中遇到一些问题，不定期更新，多字预警。\n\n1、富文本展示   text有一个decode可以解析textarea中的换行符 等符号 实现简单富文本展示 并且层级不会在最高级、可控制\n![image.png](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420624.png)\n<!-- more -->\n2、wx.setStorageSync 微信同步保存缓存 调用过多可能会报错 本地保存10MB以内 如果数据过大  在少数手机上会保存超时 解决办法 过大的数据不保存在本地 用的时候直接获取网络请求或者本地请求 (项目中遇到一个两年前的华为手机，数据量较大时会超时报错) 使用sync推荐trycatch包裹、实际项目中某些手机会报错 推荐用异步方法 wx.setStorage({})\n\n3、关于页面数据交互 两种解决办法\n>一种是使用内置方法getCurrentPage获取小程序路由堆栈[^router]获取到需要操作的路由页操作对应的方法变量等，缺点就是一单夸多个路由或复杂场景无法维护代码可读性，推荐第二种\n\n>第二种方法使用订阅发布者模式、新建一个js用于处理发布订阅逻辑或者使用npm[^publish]\n\n4、小程序网络请求可以封装在外部文件里 使用promise二次封装 提高开发效率、代码可读性，亦可统一处理header、request和response\n\n5、setData({}) 方法是异步的  同一方法内尽量少调用 会冲突导致某个setdata方法没执行 切回导致元素重绘消耗性能 解决办法 尽量调用一次 越少越好\n\n6、如果webview操作需要刷新自身的话 可以url后面加时间戳 防止因浏览器缓存没有刷新\n\n7、小程序无法动态更改tabs  所有的tabs都是在app.json中配置好的 切最多支持五个 如果小程序要实现类似用户和管理者同时打开一个小程序而展示不同的页面信息的话 有两种方案 \n\n    一种是 自制假的tabs 注入到需要用到的页面 体验不如原生完美有瑕疵\n    \n    第二种 建立一个index入口页面 在入口文件中进行权限的逻辑判断 设置一个变量保存在本地 之后进入首页后进行判断 在onload中设置需要展示的tab名字图标等信息\n```\nwx.setTabBarItem({\n    index: 0, //下标改变的\n    text: \"tab名字\",\n    iconPath: \"/utils/icon/未选中\",\n    selectedIconPath: \"/utils/icon/选择\"\n});\n```\n\n8、手机端和电脑端 通过获取时间戳的方法得到结果不一样  电脑端得到时间正常 手机端 获取时间戳 为了兼容iOS 需要写成 \"2018-06-01T00:00:00\"这种完整格式 得到的时间戳 需要减去8小时 才是正确的时间戳 注意月和日不足两位、保持两位 \n\nnew Date(\"2018-06-01T00:00:00\") / 1000 - 28800\n\n9、部分安卓机 图片地址不能有空格 不然会识别不出来 比如 aa bb.png 需写成aa_bb.png\n\n10、组件components可以使用微信提供的behaviors方法实现类似vue的mixins混入、页面page可以手动实现mixins，在微信Page(options)实例化page之前先处理一次options页面数据，判断有mixins就把需要注入的公共方法的所有方法打散到options里面 若有重复的进行覆盖合并\n\n11、项目如果用到第三方框架那么复杂的封装可以使用webpack、gulp等模块打包开发工具自定义开发可以更加契合自身项目的业务场景、按需引入 scss 、 npm、 图片压缩等提高开发效率、缩小代码体积毕竟小程序有主体包2m 分包总大小8m的限制\n\n12、一些特殊组件例如弹窗等可以参考vue 的函数式组件，通过小程的selectComponent方法实现插入，在需要用到的地方留一个锚点元素所有参数方法都在js使用中注入\n![image.png](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420368.png)\n\n[^router]: 小程序路由堆栈最多只有10条 超出替换数组最前面的\n[^publish]: Vue项目中可以使用发布订阅着模式页可以使用一个空的vue实例，通过vue内置方法\\$on、\\$emit、\\$off等也可实现 原理相同","tags":["wechat"],"categories":["wechat"]},{"title":"微信小程序-A-Z排序城市数据","url":"/2018/03/24/wechat/wx-A-Z/","content":"因为小程序项目需要城市列表选择， 之后在网上找了一些数据但是并不合适，所以从一些地图数据中搞出来了一套排序后的数据用。\n\n小程序用scroll-view 内置跳转动画 实现起来还是挺简单的；\n<!-- more -->\n![第一种](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171421692.png)\n\n循环对象展示数据  可以直接使用都是处理好的\n\n>下载地址：\n>链接: https://pan.baidu.com/s/11eU7nVAaO5RR9ksPYIpOIQ \n>密码: tnrv\n\n***\n之后用node把格式又改了一边，前端循环好循环一点 ，两种格式  都可以用\n\n![第二种](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171421368.png)\n\n好久不用node写东西，忽然还有点不适应...\n\n>下载地址：\n>链接: https://pan.baidu.com/s/1QPqoLF1UOy7zSQHBMowMLg \n>密码: hrjg\n\n***\n随手写了个原生js 的 demo ，动画没时间写将就参考下\n![demo](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171421829.gif)","tags":["wechat"],"categories":["wechat"]},{"title":"微信小程序-省市县三级联动组件city-picker","url":"/2018/03/24/wechat/wx-city-picker/","content":"\n2018年11月6日更新\n![新版效果](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171421576.gif)\n\n## 修改：\n  1. 新增半透明mask背景\n  2. 城市数据存放本地 大小400kb+有需要可以放自己服务器或者请求高德地图api\n  3. 修改样式\n  4. 修改整体字体大小\n<!-- more -->\n码云：https://gitee.com/bestjarvan/public.git\n\n***\n2018年3月24日\n进一步封装picker-view  使用高德地图城市数据 需要联网或者自行下载到本地\n\n先看效果：\n![2.gif](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171444152.gif)\n\n\n\n用法：\n\n1、把组件放到小程序的根目录下\n2、在app.js 中 请求高德地图城市数据\n>2018年11月6日更新  可根据情况添加或者不添加城市数据请求、 默认不添加 城市数据已放在本地\n```\n//判断本地是否有数据 没有 就请求\nonLaunch:() => {\n  if (!wx.getStorageSync('citys')) {\n      wx.request({\n        url: \"http://restapi.amap.com/v3/config/district?&subdistrict=3&key=你的高德key\",\n        method: \"GET\",\n        success: function (res) {\n          console.log(res['data']['districts'][0]['districts']);\n          //  请求到数据 存在本地\n          wx.setStorageSync('citys', res['data']['districts'][0]['districts']);\n        }\n      })\n    }\n}\n```\n3、在需要用的页面json中写下下列代码，路径根据自己的真实路径修改\n```\n{\n  \"usingComponents\":{\n    \"city-picker\": \"../../../components/city-picker/city-picker\"\n  }\n}\n```\n4、在页面中引用组件\n```\n//wxml\n//绑定选中事件\n<city-picker bind:selected=\"selectCity\"></city-picker>\n\n//js\nselectCity: function(e){\n  console.log(e.detail);\n  //打印出来效果{province: \"广西壮族自治区\", city: \"北海市\", county: \"合浦县\"}\n}\n```","tags":["wechat"],"categories":["wechat"]},{"title":"微信小程序-模拟iOS列表","url":"/2018/03/24/wechat/wx-iOS/","content":"最近刚写小程序 发现很多坑 不过先封装了一些简单的组件 慢慢用\n\n码云：[https://gitee.com/bestjarvan/public.git](https://gitee.com/bestjarvan/public.git)\n\n先看效果：\n<!-- more -->\n![未点击](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509394.png)\n\n![点击效果](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171509070.png)\n\n用法：\n\n1、把组件放到小程序的根目录下 \n2、在需要用的页面json中写下下列代码，路径根据自己的真实路径修改\n```\n{\n\n  \"usingComponents\":{\n\n    \"button-list\": \"/components/button-list/button-list\"\n\n  }\n\n}\n```\n3、在页面中引用组件\n```\n//wxml\n    <button-list \n      bind:myevent=\"buttonClick\"  //绑定点击事件\n      wx:for=\"{{listArr}}\"        //如果列表多的话，可以循环展示\n      text=\"{{item.name}}\"        //显示的列表名字\n      img=\"{{item.img}}\"          //名字前的图标，若不传 默认隐藏 只显示文字\n      //hideRight=\"1\"             //hideRight 是否显示右边的>号  传任意值隐藏  \n    ></button-list> \n\n//js\n//如果使用循环\n    listArr:[\n      {\n        name:'我的会员卡',\n        img:'/utils/img/my_01@3x.png'\n      },\n      {\n        name:'联系客服',\n        img:'/utils/img/my_02@3x.png'\n      }]\n\nbuttonClick:(e) => {\n    //点击事件点击之后 e.detail.type == 传入组件的text值\n    console.log(e.detail.type);\n    switch (e.detail.type){\n      case '我的会员卡':\n        //...\n        break;\n      //....\n}\n```","tags":["wechat"],"categories":["wechat"]},{"title":"ionic2极光推送iOS","url":"/2017/08/08/ionic2/ionic2-jpush-iOS/","content":"首先需要申请极光开发者账号 并且创建一个app应用，创建之后需要上传.p12格式的证书，拿到APP_KEY\n<!-- more -->\n通过 Cordova Plugins 安装，要求 Cordova CLI 5.0+：\n```\ncordova plugin add jpush-phonegap-plugin --variable APP_KEY=your_jpush_appkey\n```\n官方给的是API_KEY 我这里用APP_KEY成功了。\n\n下一步安装jpush包\n```\nnpm install ionic2-jpush --save\n```\n\n上面两个安装成功后，在config.xml中更改配置\n**注意widget 的id 要和 极光开发着账号中的Bundle ID 的值一样**\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442018.png)\n\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442487.png)\n\n\n\n![在package.json中查看配置 \"APP_KEY\"值和极光的APP_KEY一样就可以。](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442407.png)\n\n\n![之后需要在app.module.ts中providers引入](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442702.png)\n\n\n```\nimport { JPushService } from 'ionic2-jpush';\n```\n![下面就可以正常使用JPush了，在需要的页面中引入](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442923.png)\n\n\n![在constructor中构造一个JPush](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171511974.png)\n\n下面可以正常使用官方文档给的方法 \n也可以在极光上发送推送了\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442696.png)\n\n\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442938.png)\n\nps: app推送过之后会有一个角标1 打开应用后1没有消失，在xcode中发现注掉了两个方法\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171443706.png)\n\n\n","tags":["ionic2","angular","jpush"],"categories":["ionic2"]},{"title":"ionic2+cordova插件实现第三方登录","url":"/2017/07/25/ionic2/ionic2+cordova/","content":"#### 1.首先和所有的都一样，要分别到各个开放平台申请appid，添加测试账号\n\nQQ：腾讯开放平台 http://open.qq.com/\n微信：微信开放平台 https://open.weixin.qq.com/\n微博：新浪微博开放平台 http://open.weibo.com/\n<!-- more -->\n#### 2.通过cordova添加插件\nQQ:\n\n```\ncordova plugin add cordova-plugin-qqsdk --variable QQ_APP_ID=YOUR_QQ_APPID\n```\n微信:\n```\ncordova plugin add cordova-plugin-wechat  --variable wechatappid=YOUR_WECHAT_APPID\n```\n微博:\n```\ncordova plugin add cordova-plugin-weibosdk --variable WEIBO_APP_ID=YOUR_WEIBO_APPID\n```\n\n#### 3.1微博需要进一步去设置redirecturi\n在你的config.xml文件中添加\n ```<preference name=\"REDIRECTURI\" value=\"YOUR_WEIBO_REDIRECTURI\" />```\n必须要和微博开放平台里面的OAuth2.0 授权设置的一样\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442895.png)\n\n#### 3.2 QQ需要装@ionic-native/qqsdk\n\n```\nnpm install @ionic-native/qqsdk --save\n```\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442379.png)\n\n#### 3.3 微信、微博需要在编译文件中声明变量\n\n```\ndeclare var Wechat:any;\ndeclare var WeiboSDK:any;\n```\n之后就能在需要的地方直接使用Wechat.XXX 或者 WeiboSDK.XXX方法\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442089.png)\n\n#### 4.第三方登录代码\n\n  #####   4.1 QQ第三方登录:\n需要引入QQSDK模块\n```\nimport { QQSDK,QQShareOptions } from '@ionic-native/qqsdk';\n\nconstructor(public qq:QQSDK);\n\nQQLogin(){\n    const loginOptions: QQShareOptions = {\n      client: this.qq.ClientType.QQ,\n    };\n    this.qq.ssoLogin(loginOptions)\n      .then((result) => {\n        console.log('shareNews success');\n        alert('token is ' + result.access_token);\n        alert('userid is ' + result.userid);\n      })\n      .catch(error => {\n        console.log(error);\n      });\n}\n```\n\n##### 4.2 微信、微博第三方登录\n\n```\n  sinaLogin(){\n    WeiboSDK.ssoLogin(function (args) {\n      alert('access token is ' + args.access_token);\n      alert('userId is ' + args.userId);\n    }, function (failReason) {\n      alert(failReason);\n    });\n  }\n  wechatLogin(){\n    let scope = \"snsapi_userinfo\",\n      state = \"_\" + (+new Date());\n    Wechat.auth(scope, state, function (response) {\n      // you may use response.code to get the access token.\n      alert(JSON.stringify(response));\n    }, function (reason) {\n      alert(\"Failed: \" + reason);\n    });\n  }\n```\n**需要注意：**\n微信需要认证才能使用；\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171442953.png)\n\n微博：\n如果微博报错redirect_uri_mismatch 的话 请看3.1 设置redirecturi\n\n如果微博报错sso package or sign error 的话 需要在你的XCode里面的Info找到Bundle identifier这一项，复制粘贴到微博开放平台你的app中的 bundle id 中 保持两者值一致\n\n#### 5.分享和登录用法一致、安装好插件参考readme文档\n\n","tags":["ionic2","cordova","angular"],"categories":["ionic2"]},{"title":"node.js实现简单的登录注册页面","url":"/2017/07/25/node/node.js-login/","content":"首先需要新建四个文件\n\n一个服务器js\n一个保存数据的txt (代码会自动新建，手动新建也可)\n一个登陆、一个注册页面html\n<!-- more -->\ngitee：https://github.com/BestJarvan/user-register-nodejs-demo.git\n### 1.注册页面\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>register</title>\n</head>\n\n<body>\n\t<div>\n\t\t<label for=\"user\">用户名</label><input type=\"text\" id=\"user\">\n\t</div>\n\t<div>\n\t\t<label for=\"password\">密码</label><input type=\"password\" id=\"password\">\n\t</div>\n\t<div>\n\t\t<button id=\"register\">注册</button>\n\t</div>\n</body>\n<script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n<script>\n\t$(function () {\n\t\t$(\"#register\").click(function () {\n\t\t\t$.ajax({\n\t\t\t\turl: \"http://localhost:3000/register\",\n\t\t\t\ttype: \"POST\",\n\t\t\t\tdata: {\n\t\t\t\t\tusername: $(\"#user\").val(),\n\t\t\t\t\tpassword: $(\"#password\").val()\n\t\t\t\t},\n\t\t\t\tsuccess: function (res) {\n\t\t\t\t\talert(res.msg);\n\t\t\t\t\tif (res.code === 200) {\n\t\t\t\t\t\t// TODO....\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror: function (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t});\n</script>\n</html>\n```\n### 2.登录页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <title>login</title>\n</head>\n\n<body>\n  <div>\n    <label for=\"user\">用户名</label><input type=\"text\" id=\"user\">\n  </div>\n  <div>\n    <label for=\"password\">密码</label><input type=\"password\" id=\"password\">\n  </div>\n  <div>\n    <button id=\"login\">登录</button>\n    <button id=\"register\"><a href=\"register.html\">注册</a></button>\n  </div>\n</body>\n<script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n<script>\n  $(function () {\n    $(\"#login\").click(function () {\n      if ($(\"#user\").val().length == 0) {\n        return alert(\"请输入内容!\");\n      }\n      if ($(\"#password\").val().length == 0) {\n        return alert(\"请输入密码!\");\n      }\n\n      $.ajax({\n        url: \"http://localhost:3000/login\",\n        type: \"POST\",\n        data: {\n          username: $(\"#user\").val(),\n          password: $(\"#password\").val()\n        },\n        success: function (res) {\n          alert(res.msg)\n          if (res.code === 200) {\n            // TODO...\n          }\n        },\n        error: function (err) {\n          console.log(err);\n        }\n      })\n\n    })\n  });\n</script>\n</html>\n```\n### 3.搭建服务器\n\n```\nvar http = require(\"http\");\nvar url = require(\"url\");\nvar qs = require(\"querystring\");\nvar fs = require(\"fs\");\n\n// 读取文件\nfunction readFileFnc (cb, fail) {\n  fs.readFile(\"db.txt\", \"utf-8\", function (err, data) {\n    if (!err && data) {\n      console.log(\"文件中有数据\");\n      cb(data)\n    } else {\n      console.log(\"读取文件失败\");\n      fail()\n    }\n  })\n}\n\nfunction registerUser (user, res, arr) {\n  //根据前端发来的路由地址判断是登录还是注册页面，如果是注册页面\n  //同步写入db.txt文件\n  var userList = arr || []\n  userList.push(user)\n  fs.writeFileSync(\"db.txt\", JSON.stringify(userList), \"utf-8\");\n  sendMsg(res, '注册成功!', 200)\n}\n\nfunction sendMsg (res, msg, code = 200) {\n  res.writeHead(200, { 'Content-Type': 'application/json' })\n  res.end(JSON.stringify({code, msg}))\n}\n\nhttp.createServer(function (req, res) {\n  //设置请求头\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n  if (req.method == \"POST\") {\n    //接收发来的用户名和密码\n    var result = \"\";\n    //获取前端代码发来的路由地址\n    var pathName = url.parse(req.url).pathname;\n\n    req.addListener(\"data\", function (chunk) {\n      result += chunk;\n    });\n\n    req.on(\"end\", function () {\n      var user = qs.parse(result);\n      //判断用户是否存在\n      (!user.username || !user.password) && sendMsg(res, '请输入用户名或密码', 103)\n      console.log(123123);\n      if (pathName === '/login') {\n        // 登录页\n        readFileFnc(\n          function (data) {\n            var arr = JSON.parse(data);\n            //遍历整个保存数据的数组  判断登录注册\n            if (Array.isArray(arr)) {\n              const userInfo = arr.find(obj => obj.username == user.username)\n              if (userInfo) {\n                if (userInfo.password == user.password) {\n                  sendMsg(res, '登录成功！', 200)\n                } else {\n                  sendMsg(res, '密码错误！', 101)\n                }\n              } else {\n                sendMsg(res, '该用户不存在', 102)\n              }\n            }\n          },\n          function () {\n            sendMsg(res, '该用户不存在', 102)\n          }\n        )\n      } else if (pathName === '/register') {\n        // 注册页\n        console.log('zhuce')\n        readFileFnc(\n          function (data) {\n            var arr = JSON.parse(data);\n            //遍历整个保存数据的数组  判断登录注册\n            if (Array.isArray(arr)) {\n              const userInfo = arr.find(obj => obj.username == user.username)\n              if (userInfo) {\n                sendMsg(res, '该用户已存在', 101)\n              } else {\n                registerUser(user, res, arr)\n              }\n            }\n          },\n          function () {\n            registerUser(user, res)\n          }\n        )\n      }\n    });\n  } else {\n    sendMsg(res, '请使用post请求', 105)\n  }\n}).listen(3000, function (err) {\n  if (!err) {\n    console.log(\"服务器启动成功，正在监听port3000...\");\n  }\n});\n```\n### 4.在db.txt文件中可以查看注册信息\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171411744.png)\n\n------end------","tags":["javascript","nodejs","html"],"categories":["node"]},{"title":"虚拟主机个人网站发布","url":"/2017/07/25/js/虚拟主机个人网站发布/","content":"1.购买域名之前先去工信部网站查看想要购买的域名后缀能否备案\nPS:域名绑定国外服务器或主机不需要备案，国内需要到工信部备案。\n<!-- more -->\n[传送门](http://www.miitbeian.gov.cn/publish/query/indexFirst.action)\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420554.png)\n进入之后在下图域名类型名称中 输入想要购买的后缀，之后模糊查询 能查到就是可以备案 ，查询不到的 目前无法备案\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420595.png)\n2、购买域名，自己可以去万网看，价位不等\n3、购买虚拟主机\n　　　　国内有挺多免费的虚拟主机，这里用的是一个河南某安的免费主机\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420913.png)\n查看详情之后点击 直接购买 脚本默认PHP  可以选择ASP.NET\n最高年限可以选择五年\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171420927.png)\n到了这一步恭喜你已经有了自己第一个虚拟主机，点击管理可以查看主机的详细信息\n\n送的主机有1G的空间 并且没有访问流量是20G 如果是一般的个人小网站已经足够用了\n\n可以用ftp工具管理你的空间，所有的文件放到WEB文件夹下，个人主页默认会搜索WEB文件夹下根目录中的index文件(index.php , index.html等)\n最后绑定域名之后就可以通过自己的域名访问到自己WEB文件夹下的index文件了\n\n\n4、域名备案\n\n绑定域名之前需要把域名备案，在哪里买的空间就需要委托购买空间的公司备案\n\n因为用的景安的 所以还是在景安备案，找到景安主页导航栏上方的  网站备案  进入网站备案系统\n\n点击开始备案之后填写自己真实信息，根据个地市的不同要求 ，需要提供不同的材料，主要材料包括\n\n身份证正反面照片\n备案人在景安幕布前的照片\n个人核检单填写(核检单在备案系统首页中可以找到)\n根据当地特殊要求，若没有特地要求 前三个就可以了\n 备案时间：景安审核时间大概3天左右，之后景安会提交到工信部大概20天左右会发短息提示备案通过\n\n之后进行下一步\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171419774.png)\n\n5、 域名解析，绑定域名\n在景安个人中心找到并进入DNSPod解析\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171419716.png)\n之后点击添加域名 ----->输入域名后确认------>点击添加的域名右边的域名管理------>点击新增记录\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171419705.png)\n第一项主机记录填www \n记录类型选择　　CNAME\n记录值填写你的服务器的域名解析别名的值\nTTL默认600 不用修改\n![](https://gcore.jsdelivr.net/gh/BestJarvan/pic-imgs/imgs/202201171419707.png)\n下面在购买域名的地方进行域名DNS解析\n把景安的DNS填入两个确定之后48小时之内生效，快一点的大概30分钟左右\n\n一旦域名解析成功，就可以通过域名访问你的个人网站了\n\n-------end-------","categories":["js"]}]